{
  "domain": "peps/pep-0820.rst",
  "number of versions": 3,
  "diffs": [
    {
      "diff_id": 1,
      "reason type": "Other",
      "reason text": "The diff only updates metadata fields (Discussions-To URL and Post-History reference) between versions; the substantive requirements text remains unchanged. This is not a change to the meaning/intent of requirements nor a new requirement, but a metadata attribution correction.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: Pending\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: Pending\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0df319087bccc1e6e488482b9938211cf3de79ce",
        "date": "2026-01-06 14:25:03 +0100"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "diff": "PEP: 820\n Title: PySlot: Unified slot system for the C API\n Author: Petr Viktorin <encukou@gmail.com>\n-Discussions-To: Pending\n+Discussions-To: https://discuss.python.org/t/105552\n Status: Draft\n Type: Standards Track\n Created: 19-Dec-2025\n Python-Version: 3.15\n-Post-History: Pending\n+Post-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n \n \n .. highlight:: c",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 2,
      "reason type": "Meaning",
      "reason text": "Refines the Abstract to describe the new internal representation as a tagged anonymous union with flags and to explicitly tie the API changes (PyModule_FromSlotsAndSpec and the extension export hook) to the new slots, i.e., a change in design/intent rather than a simple new feature.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "Abstract\n ========\n \n-Replace type and module slots with a new, more type-safe structure that allows\n-adding new slots in a more forward-compatible way.\n+Replace type and module slots with a new structure: a tagged anonymous\n+union with flags.\n+This improves type safety and allows adding new slots\n+in a more forward-compatible way.\n+\n+API added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\n+new :external+py3.15:ref:`extension export hook <extension-export-hook>`)\n+will be changed to use the new slots.\n \n The existing slot structures and related API is soft-deprecated.\n-(That is: it will continue to work without warnings, and it\u2019ll be fully\n+(That is: they will continue to work without warnings, and it\u2019ll be fully\n documented and supported, but we plan to not add any new features to it.)",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 3,
      "reason type": "Clarification",
      "reason text": "Minor textual/formatting clarification: the description of how slots are stored was rewritten from a separate parenthetical clause to an inline form and an extra clarifying sentence 'This allows for future expansion.' added. No change to the requirement's meaning or intent; only clarifies and tightens formatting.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "allowing future CPython versions (or even alternative implementations) to\n change the details.\n \n-Both structures contain a *slots* field \u2013 essentially an array of\n-`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\n-which allows for future expansion.\n-(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n+Both structures contain a *slots* field, essentially an array of\n+`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n+(``void`` pointers taged with an ``int`` ID).\n+This allows for future expansion.\n \n In :pep:`793`, new module creation API was added.\n Instead of the ``PyModuleDef`` structure, it uses only an array of *slots*.",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 4,
      "reason type": "Clarification",
      "reason text": "The wording describing Py_mod_gil changed from 'an integer' to 'a small integer', refining the type\u2019s size to clarify the expected size without altering the overall slot semantics.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "but is technically undefined or implementation-defined behaviour in C.\n \n     For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n-    an integer, and :c:macro:`Py_tp_repr` a function; all must\n+    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n     be cast to ``void*``.\n \n Limited forward compatibility",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 5,
      "reason type": "Clarification",
      "reason text": "Introduces a formal anchor and header for the pep820 rationale and clarifies that the Rationale section is specific to pep820, providing a cross-reference anchor (_pep820-rationale) for easier navigation. This is a structural/clarification change that does not alter requirements, behavior, or functionality.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "support the ``@`` operator only on CPython versions with that operator.\n \n \n+.. _pep820-rationale:\n+\n Rationale\n =========",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 6,
      "reason type": "Clarification",
      "reason text": "A clarifying sentence was added to the Nested slot tables section to illustrate that mixing dynamically/stack-allocated slots with static ones can involve a heap-allocated module object as the module argument for PyType_FromModuleAndSpec. This does not change intent or behavior; it simply clarifies the example.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n   This solves the issue that lead to the ``PyType_From*`` family of\n-  functions expanding with values that typically can't  be ``static``\n-  (i.e. it's often a symbol from another DLL, which can't be ``static``\n-  data on Windows).\n+  functions expanding with values that typically can't  be ``static``.\n+  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n+  should be a heap-allocated module object.\n - Sharing a subset of the slots to implement functionality\n   common to several classes/modules.\n - Easily including some slots conditionally, e.g. based on the Python version.",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 7,
      "reason type": "Meaning",
      "reason text": "Dominant change: The core slot representation is redefined as a tagged anonymous union with flags, replacing the previous wording of a 'new, more type-safe structure', which changes the intended encoding/semantics of PySlot and its interaction with PyType_FromSlots/PyModule_FromSlots. This is a change in intent/behavior. Secondary changes include the addition of a 'Deprecation warnings' section (new policy for runtime deprecation) and minor editorial punctuation edits; these are editorial and do not alter core semantics.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "Fixed-width integers\n ---------------------\n \n-This proposal uses fixed-width integers (``uint16_t``), for slot IDs and\n+This proposal uses fixed-width integers (``uint16_t``) for slot IDs and\n flags.\n-With the C ``int`` type, using more that 16 bits would not be portable,\n+With the C ``int`` type, using more than 16 bits would not be portable,\n but it would silently work on common platforms.\n Using ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\n on common platforms.\n \n-With these defined as ``uint16_t``, it seems natural to use fixed-width\n-integers for everything except pointers and sizes.\n \n Memory layout\n -------------",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 8,
      "reason type": "Clarification",
      "reason text": "Minor editorial refinement in the Memory layout diff: the change clarifies that only some of the previously unused space (the 6 bytes) are repurposed, rather than all of them, and retains the note about keeping the new struct size the same on common 64-bit platforms.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "On common 64-bit platforms, we can keep the size of the new struct the same\n as the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\n struct waste 6 out of 16 bytes due to ``int`` portability and padding;\n-this proposal puts those bits to use for new features.)\n+this proposal puts some of those bits to use for new features.)\n On 32-bit platforms, this proposal calls for the same layout as on 64-bit,\n doubling the size compared to the existing structs (from 8 bytes to 16).\n For \u201cconfiguration\u201d data that's usually ``static``, it should be OK.",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 9,
      "reason type": "New",
      "reason text": "The new version adds a Deprecation warnings section that was not present in the old version, introducing runtime deprecation guidance for slot API misuse (e.g., NULL slot values, duplicate slot IDs) and related behavior. This represents a new policy/requirement rather than a mere modification of existing text.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "or harder to manage (if they're merged).\n \n \n+Deprecation warnings\n+--------------------\n+\n+Multiple slots are documented to not allow NULL values, but CPython allows\n+NULL for backwards compatibility.\n+Similarly, multiple slot IDs should not appear more than once in a single\n+array, but CPython allows such duplicates.\n+\n+This is a maintenance issue, as CPython should preserve its undocumented\n+(and often untested) behaviour in these cases as the implementation is changed.\n+\n+It also prevents API extensions.\n+For example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\n+flag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\n+the same effect.\n+\n+To allow changing the edge case behaviour in the (far) future,\n+and to allow freedom for possible alternative implementations of the C API,\n+we'll start issuing runtime deprecation warnings in these cases.\n+\n+\n Specification\n =============",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 10,
      "reason type": "Meaning",
      "reason text": "The change introduces a redesign of the slot data structure and API usage. Specifically, the slot representation is described as a tagged anonymous union with flags, and a new API path (New API section) is introduced (e.g., PyType_FromSlots and PyModule_FromSlotsAndSpec) indicating altered usage and semantics. This reflects a shift in meaning/intention toward stronger type-safety and forward-compatibility, not merely a formatting or minor editorial adjustment.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "- An union with the data, whose type depends on the slot.\n \n \n-Functions that use slots\n+New API\n+-------\n \n The following function will be added.\n It will create the corresponding Python type object from the given",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 11,
      "reason type": "Meaning",
      "reason text": "Introduces and constrains the new unified slot API: adds a requirement that Py_tp_token cannot be NULL when using PyType_FromSlots, and changes PyModule_FromSlotsAndSpec to accept the new slot structure (plus related extension export hook updates), signaling a shift to a single, type-safe slot representation and updated API semantics.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "PyObject *PyType_FromSlots(const PySlot *slots);\n \n+With this function, the ``Py_tp_token`` slot may not be set to\n+``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n+\n+\n+Changed API\n+-----------\n+\n The ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n :pep:`793`) will be *changed* to take the new slot structure::\n \n     PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n \n+The :external+py3.15:ref:`extension module export hook <extension-export-hook>`\n+added in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\n+return the new slot structure.\n+The :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\n+be updated accordingly.\n+\n \n General slot semantics\n ----------------------",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 12,
      "reason type": "Clarification",
      "reason text": "Clarification: The new version replaces the older note that the module name is stored in a Py_mod_name slot with a clearer reference showing how the new slot system affects module creation, including an explicit example that the module argument to PyType_FromModuleAndSpec should be a heap-allocated module object. This makes the reference more precise than the old version, which spoke only about a module name.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "This flag is implied for function pointers.\n \n   The flag applies even to data the slot points to \"indirectly\", except for\n-  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n+  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n   own ``PySlot_STATIC`` flag.\n   For example, if applied to a ``Py_tp_members`` slot that points to an\n   *array* of ``PyMemberDef`` structures, then the entire array, as well as the",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 13,
      "reason type": "Clarification",
      "reason text": "Rename that makes the requirement more clear.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "If the entire block is to be optional, it should end with a\n   slot with the OPTIONAL flag.\n \n-- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n+- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n   the appropriate type.\n \n   This flag simplifies porting from the existing ``PyType_Slot`` and",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 14,
      "reason type": "Clarification",
      "reason text": "The diff changes the macro flags used to indicate a pointer slot from PySlot_IS_PTR to PySlot_INTPTR (affecting PySlot_PTR and PySlot_PTR_STATIC), and adds a clarifying note that these cast to void* and do not improve type safety. This is a clarification/renaming in the implementation approach rather than adding new functionality.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "#define PySlot_END {0}\n \n We'll also add two more macros that avoid named initializers,\n-for use in C++11-compatibile code::\n+for use in C++11-compatibile code.\n+Note that these cast the value to ``void*``, so they do not improve type safety\n+over existing slots::\n \n     #define PySlot_PTR(NAME, VALUE) \\\n-       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n+       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n \n     #define PySlot_PTR_STATIC(NAME, VALUE) \\\n-       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n+       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n+\n \n+.. _pep820-nested-tables:\n \n Nested slot tables\n ------------------",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 15,
      "reason type": "Clarification",
      "reason text": "Clarification: The diff changes the pointer-data flag used when converting PyType_Slot entries (and PyModuleDef_Slot equivalents) to PySlot. The previous text used PySlot_IS_PTR; the updated text uses PySlot_INTPTR to reflect that the data in sl_ptr is a pointer-sized value. This is a semantic correction/renaming to align with the intended representation and avoid confusion about type vs pointer semantics; no functional behavior is intended to change.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n \n Each ``PyType_Slot`` in the array will be converted to\n-``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\n+``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\n and similar with ``PyModuleDef_Slot``.\n \n The initial implementation will have restrictions that may be lifted",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 16,
      "reason type": "Meaning",
      "reason text": "The Abstract's core design description changed from a generic 'new, more type-safe structure' to a concrete implementation description: a tagged anonymous union with flags. This redefines the underlying data layout and slot semantics in the requirement, while still aiming for forward-compatibility. It also notes that APIs added in 3.15 will be changed to use the new slots.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n   precedes them).\n - Nesting depth will be limited to 5 levels.\n-  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n-  which will use up one level internally.)\n \n \n New slot IDs",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 17,
      "reason type": "Clarification",
      "reason text": "Primarily a wording/terminology clarification: the diff replaces a generic reference to nested tables with a concrete cross-reference to pep820-nested-tables and expands the Py_slot_invalid description to explicitly define it as UINT16_MAX (-1). No new requirements or behavioral changes; the edits clarify existing concepts rather than introduce new functionality.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "allowed with ``Py_slot_end``.\n \n - ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n-  *Nested slot tables* above\n-- ``Py_slot_invalid``: treated as an unknown slot ID.\n+  :ref:`pep820-nested-tables` above\n+- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n+  unknown slot ID.\n \n The following new slot IDs will be added to cover existing\n members of ``PyModuleDef``:",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 18,
      "reason type": "Clarification",
      "reason text": "The change adds an explicit constraint: only the new slots Py_slot_end, Py_slot_subslots, Py_tp_slots and Py_mod_slots may be used in PyType_Spec and/or PyModuleDef. This is a clarification of API usage constraints (not a new feature) and helps prevent confusion about which slots can appear in those structures.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "None of the new slots will be usable with ``PyType_GetSlot``.\n (This limitation may be lifted in the future, with C API WG approval.)\n \n+Of the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n+``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n+\n \n Slot renumbering\n ----------------",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 19,
      "reason type": "Clarification",
      "reason text": "The diff corrects a factual error in the original text by clarifying which slots are renumbered. It states that slots for members of PyModuleDef (not PyType_Spec) are renumbered, aligning the document with the intended design described elsewhere (CPython 793). This is a clarification of terminology/scope rather than a change in meaning or behavior.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "The old numbers will remain as aliases, and will be used when compiling for\n Stable ABI versions below 3.15.\n \n-Slots for members of ``PyType_Spec``, which were added in\n+Slots for members of ``PyModuleDef``, which were added in\n :ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\n unique IDs:",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 20,
      "reason type": "Meaning",
      "reason text": "The new version deliberately changes the API behavior and evolution policy by adding runtime deprecation warnings for certain slot usages and revising the backwards-compatibility stance (renumbering, new deprecations, and changed guidance). This is a change in meaning/intent of the API surface, not a simple Typo, Summarization, or formatting change.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "This includes nested \"new-style\" slots (``Py_slot_subslots``).\n \n \n+.. _pep820-hard-deprecations:\n+\n+Deprecation warnings\n+--------------------\n+\n+CPython will emit runtime deprecation warnings for the following cases,\n+for slots where the case is currently disallowed in documentation but allowed\n+by the runtime:\n+\n+- setting a slot value to NULL:\n+\n+  - all type slots except ``Py_tp_doc``\n+  - ``Py_mod_create``\n+  - ``Py_mod_exec``\n+\n+- repeating a slot ID in a single slots array (including sub-slot arrays\n+  added in this PEP):\n+\n+  - all type slots, except slots where this is already a runtime error\n+    (``Py_tp_doc``, ``Py_tp_members``)\n+  - ``Py_mod_create``\n+  - ``Py_mod_abi``\n+\n+\n Backwards Compatibility\n =======================\n \n-This PEP only adds APIs, so it's backwards compatible.\n+This PEP proposes to change API that was already released in alpha versions of\n+Python 3.15.\n+This will inconvenience early adopters of that API, but -- as long as the\n+PEP is accepted and implemented before the first bety -- this change is within\n+the letter and spirit of our backwards compatibility policy.\n+\n+Renumbering of slots is done in a backwards-compatible way.\n+Old values continue to be accepted, and are used when compiling for\n+earlier Stable ABI.\n+\n+Some cases that are documented as illegal will begin emitting deprecation\n+warnings (see :ref:`pep820-hard-deprecations`).\n+\n+Otherwise, this PEP only adds and soft-deprecates APIs, which is backwards\n+compatible.\n \n \n Security Implications",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 21,
      "reason type": "Meaning",
      "reason text": "A substantive design rework of the slot system: the Abstract now specifies a concrete implementation (a tagged anonymous union with flags) and the New Version introduces significant API/compatibility changes, revised deprecation semantics (runtime deprecation warnings vs soft deprecation), new/changed functions and slot-ID rules, and concepts like nested slots. This alters intent/behavior beyond a mere clarification or wording adjustment.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "Reference Implementation\n ========================\n \n-None yet.\n+Draft implementation is available as `pull request #37 in the author's fork\n+<https://github.com/encukou/cpython/pull/37>`__.\n \n \n Rejected Ideas\n ==============\n \n-None yet.\n+See the :ref:`pep820-rationale` section for several alternative ideas.\n+\n+Third-party slot ID allocation\n+------------------------------\n+\n+It was suggested to allow third parties to reserve slot IDs for their own use.\n+This would be mainly useful for alternate implementations. For example,\n+something like GraalPy might want custom type slots (e.g. an \"inherits\n+from this Java class\" slot).\n+Similarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\n+typeobject struct.\n+\n+This PEP does not specify a namespace mechanism.\n+One can be added in the future.\n+We're also free to reserve individual slot IDs for alternate implementations.\n+\n+Note that slots are not a good way for *extension modules* to add extra data\n+to types or modules, as there is no API to retrieve the slots used to create\n+a specific object.\n+\n+Avoiding anonymous unions\n+-------------------------\n+\n+This PEP proposes a struct with *anonymous unions*, which are not yet used in\n+CPython's documented public API.\n+\n+There is no known issue with adding these, but the following notes may\n+be relevant:\n+\n+- Anonymous unions are only supported in C since C11.\n+  But, CPython already requires the feature, and uses it for internal members\n+  of the ``PyObject`` struct.\n+\n+- Until C++20, which adds C-style designated initializers, C++ initializers\n+  only allow setting the first member of a union.\n+  However, this is an issue for *named* unions as well.\n+  Avoiding unions entirely would mean losing most of the type-safety\n+  improvements of this PEP.\n+\n+  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n+  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n+  code that needs to be compatible with C++11 or has similar union-related\n+  limitations.\n+\n+- C++ doesn't have anonymous *structs*.\n+  This might surprise C programmers for whom anonymous structs/unions are\n+  a single language feature.\n+\n+- Non-C/C++ language wrappers may need to give the union a name.\n+  This is fine.\n+  (Dear reader: if you need this, please open a CPython issue about\n+  exposing a preferred name in headers and documentation.)\n+\n+For a bigger picture: anonymous unions can be a helpful tool for implemeting\n+tagged unions and for evolving public API in backwards-compatible ways.\n+This PEP intentionally opens the door to using them more often.\n \n \n Open Issues",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 22,
      "reason type": "Other",
      "reason text": "The changes are primarily editorial: wording changes, section renames, and minor rephrasings of the same requirements. No new requirements were introduced; the core intent remains the same (a unified slot system with a single slot structure). Thus the dominant change is editorial/clarification rather than a new or changed requirement.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new, more type-safe structure that allows\nadding new slots in a more forward-compatible way.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: it will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field \u2013 essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__,\nwhich allows for future expansion.\n(In practice, slots are ``void`` pointers taged with an ``int`` ID.)\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    an integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``\n  (i.e. it's often a symbol from another DLL, which can't be ``static``\n  data on Windows).\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``), for slot IDs and\nflags.\nWith the C ``int`` type, using more that 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\nWith these defined as ``uint16_t``, it seems natural to use fixed-width\nintegers for everything except pointers and sizes.\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nFunctions that use slots\n------------------------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see ``Py_slot_subslots`` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_IS_PTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_IS_PTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_IS_PTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n  (4 levels for the existing ``PyType_From*``, ``PyModule_From*`` functions,\n  which will use up one level internally.)\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  *Nested slot tables* above\n- ``Py_slot_invalid``: treated as an unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyType_Spec``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\nBackwards Compatibility\n=======================\n\nThis PEP only adds APIs, so it's backwards compatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nNone yet.\n\n\nRejected Ideas\n==============\n\nNone yet.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "166e82e8bc370561e9e49ebf9ba69f95d90d55a8",
        "date": "2026-01-06 14:53:31 +0100"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 820\nTitle: PySlot: Unified slot system for the C API\nAuthor: Petr Viktorin <encukou@gmail.com>\nDiscussions-To: https://discuss.python.org/t/105552\nStatus: Draft\nType: Standards Track\nCreated: 19-Dec-2025\nPython-Version: 3.15\nPost-History: `06-Jan-2026 <https://discuss.python.org/t/105552>`__\n\n\n.. highlight:: c\n\nAbstract\n========\n\nReplace type and module slots with a new structure: a tagged anonymous\nunion with flags.\nThis improves type safety and allows adding new slots\nin a more forward-compatible way.\n\nAPI added in 3.15 (:external+py3.15:c:func:`PyModule_FromSlotsAndSpec` and the\nnew :external+py3.15:ref:`extension export hook <extension-export-hook>`)\nwill be changed to use the new slots.\n\nThe existing slot structures and related API is soft-deprecated.\n(That is: they will continue to work without warnings, and it\u2019ll be fully\ndocumented and supported, but we plan to not add any new features to it.)\n\n\nBackground\n==========\n\nThe C API in Python 3.14 contains two extendable structs used to provide\ninformation when creating a new object: :c:type:`PyType_Spec` and\n:c:type:`PyModuleDef`.\n\nEach has a family of C API functions that create a Python object from it.\n(Each family works as a single function, with optional arguments that\ngot added over time.) These are:\n\n* ``PyType_From*`` functions, like :c:func:`PyType_FromMetaclass`,\n  for ``PyType_Spec``;\n* ``PyModule_FromDef*`` functions, like :c:func:`PyModule_FromDefAndSpec`,\n  for ``PyModuleDef``.\n\nSeparating \"input\" structures from runtime objects allows the internal\nstructure of the object to stay opaque (in both the API and the ABI),\nallowing future CPython versions (or even alternative implementations) to\nchange the details.\n\nBoth structures contain a *slots* field, essentially an array of\n`tagged unions <https://en.wikipedia.org/wiki/Tagged_union>`__\n(``void`` pointers taged with an ``int`` ID).\nThis allows for future expansion.\n\nIn :pep:`793`, new module creation API was added.\nInstead of the ``PyModuleDef`` structure, it uses only an array of *slots*.\nTo replace the existing members of ``PyModuleDef``, it adds\ncorresponding slot IDs -- for example, the module name is specified in a\n``Py_mod_name`` slot, rather than in ``PyModuleDef.m_name``.\nThat PEP notes:\n\n\n    The PyModuleDef_Slot struct does have some downsides compared to fixed\n    fields.\n    We believe these are fixable, but leave that out of scope of this PEP.\n\nThis proposal addresses the downsides.\n\n\nMotivation\n==========\n\nThe main shortcomings of the existing ``PyModuleDef_Slot`` and ``PyType_Slot``\nare:\n\nType safety\n    ``void *`` is used for data pointers, function pointers and small integers,\n    requiring casting that works in practice on all relevant architectures,\n    but is technically undefined or implementation-defined behaviour in C.\n\n    For example: :c:macro:`Py_tp_doc` marks a string; :c:macro:`Py_mod_gil`\n    a small integer, and :c:macro:`Py_tp_repr` a function; all must\n    be cast to ``void*``.\n\nLimited forward compatibility\n    If an extension provides a slot ID that's unknown to the current\n    interpreter, type/module creation will fail.\n    This makes it cumbersome to use \"optional\" features \u2013 ones that should\n    only take effect if the interpreter supports them.\n    The recently added slots :c:macro:`Py_mod_gil` and\n    :c:macro:`Py_mod_multiple_interpreters` are good examples.\n\n    One workaround is to check the Python version, and omit slots\n    that predate the current interpreter.\n    This is cumbersome for users.\n    It also constraints possible non-CPython implementations of the C API,\n    preventing them from \"cherry-picking\" features introduced in newer CPython\n    versions.\n\n\nExample\n=======\n\nThis proposal adds API to create classes and modules from arrays of slots,\nwhich can be specified as C literals using macros, like this::\n\n    static PySlot myClass_slots[] = {\n       PySlot_STATIC(tp_name, \"mymod.MyClass\"),\n       PySlot_SIZE(tp_extra_basicsize, sizeof(struct myClass)),\n       PySlot_FUNC(tp_repr, myClass_repr),\n       PySlot_INT64(tp_flags, Py_TPFLAGS_DEFAULT | Py_TPFLAGS_MANAGED_DICT),\n       PySlot_END,\n    }\n\n    // ...\n\n    PyObject *MyClass = PyType_FromSlots(myClass_slots, -1);\n\nThe macros simplify hand-written literals.\nFor more complex use cases, like compatibility between several Python versions,\nor templated/auto-generated slot arrays, as well as for non-C users of the\nC API, the slot struct definitions can be written out.\nFor example, if the transition from ``tp_getattr`` to ``tp_getattro``\nwas happening in the near future (say, CPython 3.17), rather than 1.4, and\nthe user wanted to support CPython with and without ``tp_getattro``, they could\nadd a \"``HAS_FALLBACK``\" flag::\n\n    static PySlot myClass_slots[] = {\n       ...\n       {   // skipped if not supported\n           .sl_id=Py_tp_getattro,\n           .sl_flags=PySlot_HAS_FALLBACK,\n           .sl_func=myClass_getattro,\n       },\n       {    // used if if the slot above was skipped\n           .sl_id=Py_tp_getattr,\n           .sl_func=myClass_old_getattr,\n       },\n       PySlot_END,\n    }\n\nSimilarly, if the ``nb_matrix_multiply`` slot (:pep:`465`) was added in the\nnear future, users could add it with an \"``OPTIONAL``\" flag, making their class\nsupport the ``@`` operator only on CPython versions with that operator.\n\n\n.. _pep820-rationale:\n\nRationale\n=========\n\nHere we explain the design decisions in this proposal.\n\nSome of the rationale is repeated from :pep:`793`, which replaced\nthe :c:type:`PyModuleDef` struct with an array of slots.\n\n\nUsing slots\n-----------\n\nThe main alternative to slots is using a versioned ``struct`` for input.\n\nThere are two variants of such a design:\n\n- A large struct with fields for all info. As we can see with\n  ``PyTypeObject``, most of such a struct tends to be NULLs in practice.\n  As more fields become obsolete, either the wastage grows, or we introduce new\n  struct layouts (while keeping compatibility with the old ones for a while).\n\n- A small struct with only the info necessary for initial creation, with other\n  info added afterwards (with dedicated function calls, or Python-level\n  ``setattr``). This design:\n\n  - makes it cumbersome to add/obsolete/adjust the required info (for example,\n    in :PEP:`697` I gave meaning to negative values of an existing field;\n    adding a new field would be cleaner in similar situations);\n  - increases the number of API calls between an extension and the interpreter.\n\n  We believe that \u201cbatch\u201d API for type/module creation makes sense,\n  even if it partially duplicates an API to modify \u201clive\u201d objects.\n\n\nUsing slots *only*\n------------------\n\nThe classes ``PyType_Spec`` and ``PyModuleDef`` have explicit fields\nin addition to a slots array. These include:\n\n- Required information, such as the class name (``PyType_Spec.name``).\n  This proposal adds a *slot* ID for the name, and makes it required.\n- Non-pointers (``basicsize``, ``flags``).\n  Originally, slots were intended to\n  only contain *function pointers*; they now contain *data pointers* as well as\n  integers or flags. This proposal uses a union to handle types cleanly.\n- Items added before the slots mechanism. The ``PyModuleDef.m_slots``\n  itself was repurposed from ``m_reload`` which was always NULL;\n  the optional ``m_traverse`` or ``m_methods`` members predate it.\n\nWe can do without these fields, and have *only* an array of slots.\nA wrapper class around the array would complicate the design.\nIf fields in such a class ever become obsolete, they are hard to remove or\nrepurpose.\n\n\nNested slot tables\n------------------\n\nIn this proposal, the array of slots can reference another array of slots,\nwhich is treated as if it was merged into its \u201cparent\u201d, recursively.\nThis complicates slot handling inside the interpreter, but allows:\n\n- Mixing dynamically allocated (or stack-allocated) slots with ``static`` ones.\n  This solves the issue that lead to the ``PyType_From*`` family of\n  functions expanding with values that typically can't  be ``static``.\n  For example, the *module* argument to :c:func:`PyType_FromModuleAndSpec`\n  should be a heap-allocated module object.\n- Sharing a subset of the slots to implement functionality\n  common to several classes/modules.\n- Easily including some slots conditionally, e.g. based on the Python version.\n\n\nNested \u201clegacy\u201d slot tables\n---------------------------\n\nSimilarly to nested arrays of ``PyType_Slot``, we also propose supporting\narrays of \u201clegacy\u201d slots (``PyType_Slot`` and ``PyModuleDef_Slot``) in\nthe \u201cnew\u201d slots, and vice versa.\n\nThis way, users can reuse code they already have written without\nrewriting/reformatting,\nand only use the \u201cnew\u201d slots if they need any new features.\n\n\nFixed-width integers\n---------------------\n\nThis proposal uses fixed-width integers (``uint16_t``) for slot IDs and\nflags.\nWith the C ``int`` type, using more than 16 bits would not be portable,\nbut it would silently work on common platforms.\nUsing ``int`` but avoiding values over ``UINT16_MAX`` wastes 16 bits\non common platforms.\n\n\nMemory layout\n-------------\n\nOn common 64-bit platforms, we can keep the size of the new struct the same\nas the existing ``PyType_Slot`` and ``PyModuleDef_Slot``. (The existing\nstruct waste 6 out of 16 bytes due to ``int`` portability and padding;\nthis proposal puts some of those bits to use for new features.)\nOn 32-bit platforms, this proposal calls for the same layout as on 64-bit,\ndoubling the size compared to the existing structs (from 8 bytes to 16).\nFor \u201cconfiguration\u201d data that's usually ``static``, it should be OK.\n\nThe proposal does not use bit-fields and enums, whose memory representation is\ncompiler-dependent, causing issues when using the API from languages other\nthan C.\n\nThe structure is laid out assuming that a type's alignment matches its size.\n\n\nSingle ID space\n---------------\n\nCurrently, the numeric values of *module* and *type* slots overlap:\n\n- ``Py_bf_getbuffer`` == ``Py_mod_create`` == 1\n- ``Py_bf_releasebuffer`` == ``Py_mod_exec`` == 2\n- ``Py_mp_ass_subscript`` == ``Py_mod_multiple_interpreters`` == 3\n- ``Py_mp_length`` == ``Py_mod_gil`` == 4\n- and similar for module slots added in CPython 3.15\n\nThis proposal use a single sequence for both, so future slots avoid this\noverlap. This is to:\n\n- Avoid *accidentally* using type slots for modules, and vice versa\n- Allow external libraries or checkers to determine a slot's meaning\n  (and type) based on the ID.\n\nThe 4 existing overlaps means we don't reach these goals right now,\nbut we can gradually migrate to new numeric IDs in a way that's transparent\nto the user.\n\nThe main disadvantage is that any internal lookup tables will be either bigger\n(if we use separate ones for types & modules, so they'll contain blanks),\nor harder to manage (if they're merged).\n\n\nDeprecation warnings\n--------------------\n\nMultiple slots are documented to not allow NULL values, but CPython allows\nNULL for backwards compatibility.\nSimilarly, multiple slot IDs should not appear more than once in a single\narray, but CPython allows such duplicates.\n\nThis is a maintenance issue, as CPython should preserve its undocumented\n(and often untested) behaviour in these cases as the implementation is changed.\n\nIt also prevents API extensions.\nFor example, instead of adding the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION`\nflag in 3.10, we could have allowed settning the ``Py_tp_new`` slot to NULL for\nthe same effect.\n\nTo allow changing the edge case behaviour in the (far) future,\nand to allow freedom for possible alternative implementations of the C API,\nwe'll start issuing runtime deprecation warnings in these cases.\n\n\nSpecification\n=============\n\nA new ``PySlot`` structure will be defined as follows::\n\n    typedef struct PySlot {\n        uint16_t sl_id;\n        uint16_t sl_flags;\n        union {\n            uint32_t _sl_reserved;  // must be 0\n        };\n        union {\n            void *sl_ptr;\n            void (*sl_func)(void);\n            Py_ssize_t sl_size;\n            int64_t sl_int64;\n            uint64_t sl_uint64;\n        };\n    } PySlot;\n\n\n- ``sl_id``: A slot number, identifying what the slot does.\n- ``sl_flags``: Flags, defined below.\n- 32 bits reserved for future extensions (expected to be enabled by\n  future flags).\n- An union with the data, whose type depends on the slot.\n\n\nNew API\n-------\n\nThe following function will be added.\nIt will create the corresponding Python type object from the given\narray of slots::\n\n    PyObject *PyType_FromSlots(const PySlot *slots);\n\nWith this function, the ``Py_tp_token`` slot may not be set to\n``Py_TP_USE_SPEC`` (i.e. ``NULL``).\n\n\nChanged API\n-----------\n\nThe ``PyModule_FromSlotsAndSpec`` function (added in CPython 3.15 in\n:pep:`793`) will be *changed* to take the new slot structure::\n\n    PyObject *PyModule_FromSlotsAndSpec(const PySlot *slots, PyObject *spec)\n\nThe :external+py3.15:ref:`extension module export hook <extension-export-hook>`\nadded in :pep:`793` (:samp:`PyModExport_{<name>}`) will be *changed* to\nreturn the new slot structure.\nThe :external+py3.15:c:macro:`PyMODEXPORT_FUNC` macro will\nbe updated accordingly.\n\n\nGeneral slot semantics\n----------------------\n\nWhen slots are passed to a function that applies them, the function will not\nmodify the slot array, nor any data it points to (recursively).\n\nAfter the function is done, the user is allowed to modify or deallocate the\narray, and any data it points to (recursively), unless it's explicitly marked\nas \"static\" (see ``PySlot_STATIC`` below).\nThis means the interpreter typically needs to make a copy of all data\nin the struct, including ``char *`` text.\n\n\nFlags\n-----\n\n``sl_flags`` may set the following bits. Unassigned bits must be set to zero.\n\n- ``PySlot_OPTIONAL``: If the slot ID is unknown, the interpreter should\n  ignore the slot entirely. (For example, if ``nb_matrix_multiply`` was being\n  added to CPython now, your type could use this.)\n\n- ``PySlot_STATIC``: All data the slot points to is statically allocated\n  and constant.\n  Thus, the interpreter does not need to copy the information.\n  This flag is implied for function pointers.\n\n  The flag applies even to data the slot points to \"indirectly\", except for\n  nested slots -- see :ref:`pep820-nested-tables` below -- which can have their\n  own ``PySlot_STATIC`` flag.\n  For example, if applied to a ``Py_tp_members`` slot that points to an\n  *array* of ``PyMemberDef`` structures, then the entire array, as well as the\n  ``name`` and ``doc`` strings in its elements, must be static and constant.\n\n- ``PySlot_HAS_FALLBACK``: If the slot ID is unknown, the interpreter will\n  ignore the slot.\n  If it's known, the interpreter should ignore subsequent slots up to\n  (and including) the first one without HAS_FALLBACK.\n\n  Effectively, consecutive slots with the HAS_FALLBACK flag, plus the first\n  non-HAS_FALLBACK slot after them, form a \u201cblock\u201d where the the interpreter\n  will only consider the *first* slot in the block that it understands.\n  If the entire block is to be optional, it should end with a\n  slot with the OPTIONAL flag.\n\n- ``PySlot_INTPTR``: The data is stored in ``sl_ptr``, and must be cast to\n  the appropriate type.\n\n  This flag simplifies porting from the existing ``PyType_Slot`` and\n  ``PyModuleDef_Slot``, where all slots work this way.\n\n\nConvenience macros\n------------------\n\nThe following macros will be added to the API to simplify slot definition::\n\n    #define PySlot_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_ptr=(void*)(VALUE)}\n\n    #define PySlot_FUNC(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_func=(VALUE)}\n\n    #define PySlot_SIZE(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_size=(VALUE)}\n\n    #define PySlot_INT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_int64=(VALUE)}\n\n    #define PySlot_UINT64(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_uint64=(VALUE)}\n\n    #define PySlot_STATIC_DATA(NAME, VALUE) \\\n       {.sl_id=NAME, .sl_flags=PySlot_STATIC, .sl_ptr=(VALUE)}\n\n    #define PySlot_END {0}\n\nWe'll also add two more macros that avoid named initializers,\nfor use in C++11-compatibile code.\nNote that these cast the value to ``void*``, so they do not improve type safety\nover existing slots::\n\n    #define PySlot_PTR(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR, {0}, {(void*)(VALUE)}}\n\n    #define PySlot_PTR_STATIC(NAME, VALUE) \\\n       {NAME, PySlot_INTPTR|Py_SLOT_STATIC, {0}, {(void*)(VALUE)}}\n\n\n.. _pep820-nested-tables:\n\nNested slot tables\n------------------\n\nA new slot, ``Py_slot_subslots``, will be added to allow nesting slot tables.\nIts value (``sl_ptr``) should point to an array of ``PySlot`` structures,\nwhich will be treated as if they were part of the current slot array.\n``sl_ptr`` can be ``NULL`` to indicate that there are no slots.\n\nTwo more slots will allow similar nesting for existing slot structures:\n\n- ``Py_tp_slots`` for an array of ``PyType_Slot``\n- ``Py_mod_slots`` for an array of ``PyModuleDef_Slot``\n\nEach ``PyType_Slot`` in the array will be converted to\n``(PySlot){.sl_id=slot, .sl_flags=PySlot_INTPTR, .sl_ptr=func}``,\nand similar with ``PyModuleDef_Slot``.\n\nThe initial implementation will have restrictions that may be lifted\nin the future:\n\n- ``Py_slot_subslots``, ``Py_tp_slots`` and ``Py_mod_slots`` cannot use\n  ``PySlot_HAS_FALLBACK`` (the flag cannot be set on them nor a slot that\n  precedes them).\n- Nesting depth will be limited to 5 levels.\n\n\nNew slot IDs\n------------\n\nThe following new slot IDs, usable for both type and module\ndefinitions, will be added:\n\n- ``Py_slot_end`` (defined as ``0``): Marks the end of a slots array.\n\n  - The ``PySlot_INTPTR`` and ``PySlot_STATIC`` flags are ignored.\n  - The ``PySlot_OPTIONAL`` and ``PySlot_HAS_FALLBACK`` flags are not\n    allowed with ``Py_slot_end``.\n\n- ``Py_slot_subslots``, ``Py_tp_slots``, ``Py_mod_slots``: see\n  :ref:`pep820-nested-tables` above\n- ``Py_slot_invalid`` (defined as ``UINT16_MAX``, i.e. ``-1``): treated as an\n  unknown slot ID.\n\nThe following new slot IDs will be added to cover existing\nmembers of ``PyModuleDef``:\n\n- ``Py_tp_name`` (mandatory for type creation)\n- ``Py_tp_basicsize`` (of type ``Py_ssize_t``)\n- ``Py_tp_extra_basicsize`` (equivalent to setting ``PyType_Spec.basicsize``\n  to ``-extra_basicsize``)\n- ``Py_tp_itemsize``\n- ``Py_tp_flags``\n\nThe following new slot IDs will be added to cover\narguments of ``PyType_FromMetaclass``:\n\n- ``Py_tp_metaclass`` (used to set ``ob_type`` after metaclass calculation)\n- ``Py_tp_module``\n\nNote that ``Py_tp_base`` and ``Py_tp_bases`` already exist.\nThe interpreter will treat them identically: either can specify a class\nobject or a tuple of them.\n``Py_tp_base`` will be soft-deprecated in favour of ``Py_tp_bases``.\nSpecifying both in a single definition will be deprecated (currently,\n``Py_tp_bases`` overrides ``Py_tp_base``).\n\nNone of the new slots will be usable with ``PyType_GetSlot``.\n(This limitation may be lifted in the future, with C API WG approval.)\n\nOf the new slots, only ``Py_slot_end``, ``Py_slot_subslots``, ``Py_tp_slots``,\n``Py_mod_slots`` will be allowed in ``PyType_Spec`` and/or ``PyModuleDef``.\n\n\nSlot renumbering\n----------------\n\nNew slots IDs will have unique numeric values (that is, ``Py_slot_*``,\n``Py_tp_*`` and ``Py_mod_*`` won't share IDs).\n\nSlots numbered 1 through 4 (``Py_bf_getbuffer``...\\ ``Py_mp_length`` and\n``Py_mod_create``...\\ ``Py_mod_gil``) will be redefined as new\n(larger) numbers.\nThe old numbers will remain as aliases, and will be used when compiling for\nStable ABI versions below 3.15.\n\nSlots for members of ``PyModuleDef``, which were added in\n:ref:`PEP 793 <pep793-api-summary>`, will be renumbered so that they have\nunique IDs:\n\n- ``Py_mod_name``\n- ``Py_mod_doc``\n- ``Py_mod_state_size``\n- ``Py_mod_methods``\n- ``Py_mod_state_traverse``\n- ``Py_mod_state_clear``\n- ``Py_mod_state_free``\n\n\nSoft deprecation\n----------------\n\nThese existing functions will be :pep:`soft-deprecated <387#soft-deprecation>`:\n\n- ``PyType_FromSpec``\n- ``PyType_FromSpecWithBases``\n- ``PyType_FromModuleAndSpec``\n- ``PyType_FromMetaclass``\n- ``PyModule_FromDefAndSpec``\n- ``PyModule_FromDefAndSpec2``\n- ``PyModule_ExecDef``\n\n(As a reminder: soft-deprecated API is not scheduled for removal, does not\nraise warnings, and remains documented and tested. However, no new\nfunctionality will be added to it.)\n\nArrays of ``PyType_Slot`` or ``PyModuleDef_Slot``, which are accepted by\nthese functions, can contain any slots, including \"new\" ones defined\nin this PEP.\nThis includes nested \"new-style\" slots (``Py_slot_subslots``).\n\n\n.. _pep820-hard-deprecations:\n\nDeprecation warnings\n--------------------\n\nCPython will emit runtime deprecation warnings for the following cases,\nfor slots where the case is currently disallowed in documentation but allowed\nby the runtime:\n\n- setting a slot value to NULL:\n\n  - all type slots except ``Py_tp_doc``\n  - ``Py_mod_create``\n  - ``Py_mod_exec``\n\n- repeating a slot ID in a single slots array (including sub-slot arrays\n  added in this PEP):\n\n  - all type slots, except slots where this is already a runtime error\n    (``Py_tp_doc``, ``Py_tp_members``)\n  - ``Py_mod_create``\n  - ``Py_mod_abi``\n\n\nBackwards Compatibility\n=======================\n\nThis PEP proposes to change API that was already released in alpha versions of\nPython 3.15.\nThis will inconvenience early adopters of that API, but -- as long as the\nPEP is accepted and implemented before the first bety -- this change is within\nthe letter and spirit of our backwards compatibility policy.\n\nRenumbering of slots is done in a backwards-compatible way.\nOld values continue to be accepted, and are used when compiling for\nearlier Stable ABI.\n\nSome cases that are documented as illegal will begin emitting deprecation\nwarnings (see :ref:`pep820-hard-deprecations`).\n\nOtherwise, this PEP only adds and soft-deprecates APIs, which is backwards\ncompatible.\n\n\nSecurity Implications\n=====================\n\nNone known\n\n\nHow to Teach This\n=================\n\nAdjust the \"Extending and Embedding\" tutorial to use this.\n\n\nReference Implementation\n========================\n\nDraft implementation is available as `pull request #37 in the author's fork\n<https://github.com/encukou/cpython/pull/37>`__.\n\n\nRejected Ideas\n==============\n\nSee the :ref:`pep820-rationale` section for several alternative ideas.\n\nThird-party slot ID allocation\n------------------------------\n\nIt was suggested to allow third parties to reserve slot IDs for their own use.\nThis would be mainly useful for alternate implementations. For example,\nsomething like GraalPy might want custom type slots (e.g. an \"inherits\nfrom this Java class\" slot).\nSimilarly, at one point PyPy had an extra ``tp_pypy_flags`` in their\ntypeobject struct.\n\nThis PEP does not specify a namespace mechanism.\nOne can be added in the future.\nWe're also free to reserve individual slot IDs for alternate implementations.\n\nNote that slots are not a good way for *extension modules* to add extra data\nto types or modules, as there is no API to retrieve the slots used to create\na specific object.\n\nAvoiding anonymous unions\n-------------------------\n\nThis PEP proposes a struct with *anonymous unions*, which are not yet used in\nCPython's documented public API.\n\nThere is no known issue with adding these, but the following notes may\nbe relevant:\n\n- Anonymous unions are only supported in C since C11.\n  But, CPython already requires the feature, and uses it for internal members\n  of the ``PyObject`` struct.\n\n- Until C++20, which adds C-style designated initializers, C++ initializers\n  only allow setting the first member of a union.\n  However, this is an issue for *named* unions as well.\n  Avoiding unions entirely would mean losing most of the type-safety\n  improvements of this PEP.\n\n  Note that the proposed flag ``PySlot_INTPTR``, and the workaround macros\n  ``PySlot_PTR`` & ``PySlot_PTR_STATIC``, allow using this API in\n  code that needs to be compatible with C++11 or has similar union-related\n  limitations.\n\n- C++ doesn't have anonymous *structs*.\n  This might surprise C programmers for whom anonymous structs/unions are\n  a single language feature.\n\n- Non-C/C++ language wrappers may need to give the union a name.\n  This is fine.\n  (Dear reader: if you need this, please open a CPython issue about\n  exposing a preferred name in headers and documentation.)\n\nFor a bigger picture: anonymous unions can be a helpful tool for implemeting\ntagged unions and for evolving public API in backwards-compatible ways.\nThis PEP intentionally opens the door to using them more often.\n\n\nOpen Issues\n===========\n\nNone yet.\n\n\nAcknowledgements\n================\n\nThanks to Da Woods, Antoine Pitrou and Mark Shannon\nfor substantial input on this iteration of the proposal.\n\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "8c68109ac7f8ae5ac94bfd988b16beb9fc322ded",
        "date": "2026-01-28 21:35:29 +0100"
      },
      "diff": "None yet.\n \n \n+Acknowledgements\n+================\n+\n+Thanks to Da Woods, Antoine Pitrou and Mark Shannon\n+for substantial input on this iteration of the proposal.\n+\n+\n Copyright\n =========",
      "old_content_snippet": "",
      "new_content_snippet": ""
    }
  ]
}