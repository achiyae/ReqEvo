{
  "domain": "peps/pep-3155.rst",
  "number of versions": 5,
  "diffs": [
    {
      "diff_id": 1,
      "reason type": "Other",
      "reason text": "Eliminated the Local Variables block (editor configuration) at the end of the document; this is boilerplate/metadata formatting with no impact on the specification content.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 3155\nTitle: Qualified name for classes and functions\nVersion: $Revision$\nLast-Modified: $Date$\nAuthor: Antoine Pitrou <solipsis@pitrou.net>\nStatus: Final\nType: Standards Track\nContent-Type: text/x-rst\nCreated: 29-Oct-2011\nPython-Version: 3.3\nPost-History:\nResolution: https://mail.python.org/pipermail/python-dev/2011-November/114545.html\n\n\nRationale\n=========\n\nPython's introspection facilities have long had poor support for\nnested classes.  Given a class object, it is impossible to know\nwhether it was defined inside another class or at module top-level;\nand, if the former, it is also impossible to know in which class it\nwas defined.  While use of nested classes is often considered poor\nstyle, the only reason for them to have second class introspection\nsupport is a lousy pun.\n\nPython 3 adds insult to injury by dropping what was formerly known as\nunbound methods.  In Python 2, given the following definition::\n\n    class C:\n        def f():\n            pass\n\nyou can then walk up from the ``C.f`` object to its defining class::\n\n    >>> C.f.im_class\n    <class '__main__.C'>\n\nThis possibility is gone in Python 3::\n\n    >>> C.f.im_class\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    AttributeError: 'function' object has no attribute 'im_class'\n    >>> dir(C.f)\n    ['__annotations__', '__call__', '__class__', '__closure__', '__code__',\n    '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__',\n    '__eq__', '__format__', '__ge__', '__get__', '__getattribute__',\n    '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__',\n    '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__',\n    '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',\n    '__str__', '__subclasshook__']\n\nThis limits again the introspection capabilities available to the\nuser.  It can produce actual issues when porting software to Python 3,\nfor example Twisted Core where the issue of introspecting method\nobjects came up several times.  It also limits pickling support [1]_.\n\n\nProposal\n========\n\nThis PEP proposes the addition of a ``__qualname__`` attribute to\nfunctions and classes.  For top-level functions and classes, the\n``__qualname__`` attribute is equal to the ``__name__`` attribute.  For\nnested classes, methods, and nested functions, the ``__qualname__``\nattribute contains a dotted path leading to the object from the module\ntop-level.  A function's local namespace is represented in that dotted\npath by a component named ``<locals>``.\n\nThe repr() and str() of functions and classes is modified to use\n``__qualname__`` rather than ``__name__``.\n\nExample with nested classes\n---------------------------\n\n>>> class C:\n...   def f(): pass\n...   class D:\n...     def g(): pass\n...\n>>> C.__qualname__\n'C'\n>>> C.f.__qualname__\n'C.f'\n>>> C.D.__qualname__\n'C.D'\n>>> C.D.g.__qualname__\n'C.D.g'\n\nExample with nested functions\n-----------------------------\n\n>>> def f():\n...   def g(): pass\n...   return g\n...\n>>> f.__qualname__\n'f'\n>>> f().__qualname__\n'f.<locals>.g'\n\n\nLimitations\n===========\n\nWith nested functions (and classes defined inside functions), the\ndotted path will not be walkable programmatically as a function's\nnamespace is not available from the outside.  It will still be more\nhelpful to the human reader than the bare ``__name__``.\n\nAs the ``__name__`` attribute, the ``__qualname__`` attribute is computed\nstatically and it will not automatically follow rebinding.\n\n\nDiscussion\n==========\n\nExcluding the module name\n-------------------------\n\nAs ``__name__``, ``__qualname__`` doesn't include the module name.  This\nmakes it independent of module aliasing and rebinding, and also allows to\ncompute it at compile time.\n\nReviving unbound methods\n------------------------\n\nReviving unbound methods would only solve a fraction of the problems this\nPEP solves, at a higher price (an additional object type and an additional\nindirection, rather than an additional attribute).\n\n\nNaming choice\n=============\n\n\"Qualified name\" is the best approximation, as a short phrase, of what the\nadditional attribute is about.  It is not a \"full name\" or \"fully qualified\nname\" since it (deliberately) does not include the module name.  Calling\nit a \"path\" would risk confusion with filesystem paths and the ``__file__``\nattribute.\n\nThe first proposal for the attribute name was to call it ``__qname__`` but\nmany people (who are not aware of previous use of such jargon in e.g. the\nXML specification [2]_) found it obscure and non-obvious, which is why the\nslightly less short and more explicit ``__qualname__`` was finally chosen.\n\n\nReferences\n==========\n\n.. [1] \"pickle should support methods\":\n   http://bugs.python.org/issue9276\n\n.. [2] \"QName\" entry in Wikipedia:\n   http://en.wikipedia.org/wiki/QName\n\n\nCopyright\n=========\n\nThis document has been placed in the public domain.\n\n\n\n..\n   Local Variables:\n   mode: indented-text\n   indent-tabs-mode: nil\n   sentence-end-double-space: t\n   fill-column: 70\n   coding: utf-8\n   End:"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 3155\nTitle: Qualified name for classes and functions\nVersion: $Revision$\nLast-Modified: $Date$\nAuthor: Antoine Pitrou <solipsis@pitrou.net>\nStatus: Final\nType: Standards Track\nContent-Type: text/x-rst\nCreated: 29-Oct-2011\nPython-Version: 3.3\nPost-History:\nResolution: https://mail.python.org/pipermail/python-dev/2011-November/114545.html\n\n\nRationale\n=========\n\nPython's introspection facilities have long had poor support for\nnested classes.  Given a class object, it is impossible to know\nwhether it was defined inside another class or at module top-level;\nand, if the former, it is also impossible to know in which class it\nwas defined.  While use of nested classes is often considered poor\nstyle, the only reason for them to have second class introspection\nsupport is a lousy pun.\n\nPython 3 adds insult to injury by dropping what was formerly known as\nunbound methods.  In Python 2, given the following definition::\n\n    class C:\n        def f():\n            pass\n\nyou can then walk up from the ``C.f`` object to its defining class::\n\n    >>> C.f.im_class\n    <class '__main__.C'>\n\nThis possibility is gone in Python 3::\n\n    >>> C.f.im_class\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    AttributeError: 'function' object has no attribute 'im_class'\n    >>> dir(C.f)\n    ['__annotations__', '__call__', '__class__', '__closure__', '__code__',\n    '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__',\n    '__eq__', '__format__', '__ge__', '__get__', '__getattribute__',\n    '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__',\n    '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__',\n    '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',\n    '__str__', '__subclasshook__']\n\nThis limits again the introspection capabilities available to the\nuser.  It can produce actual issues when porting software to Python 3,\nfor example Twisted Core where the issue of introspecting method\nobjects came up several times.  It also limits pickling support [1]_.\n\n\nProposal\n========\n\nThis PEP proposes the addition of a ``__qualname__`` attribute to\nfunctions and classes.  For top-level functions and classes, the\n``__qualname__`` attribute is equal to the ``__name__`` attribute.  For\nnested classes, methods, and nested functions, the ``__qualname__``\nattribute contains a dotted path leading to the object from the module\ntop-level.  A function's local namespace is represented in that dotted\npath by a component named ``<locals>``.\n\nThe repr() and str() of functions and classes is modified to use\n``__qualname__`` rather than ``__name__``.\n\nExample with nested classes\n---------------------------\n\n>>> class C:\n...   def f(): pass\n...   class D:\n...     def g(): pass\n...\n>>> C.__qualname__\n'C'\n>>> C.f.__qualname__\n'C.f'\n>>> C.D.__qualname__\n'C.D'\n>>> C.D.g.__qualname__\n'C.D.g'\n\nExample with nested functions\n-----------------------------\n\n>>> def f():\n...   def g(): pass\n...   return g\n...\n>>> f.__qualname__\n'f'\n>>> f().__qualname__\n'f.<locals>.g'\n\n\nLimitations\n===========\n\nWith nested functions (and classes defined inside functions), the\ndotted path will not be walkable programmatically as a function's\nnamespace is not available from the outside.  It will still be more\nhelpful to the human reader than the bare ``__name__``.\n\nAs the ``__name__`` attribute, the ``__qualname__`` attribute is computed\nstatically and it will not automatically follow rebinding.\n\n\nDiscussion\n==========\n\nExcluding the module name\n-------------------------\n\nAs ``__name__``, ``__qualname__`` doesn't include the module name.  This\nmakes it independent of module aliasing and rebinding, and also allows to\ncompute it at compile time.\n\nReviving unbound methods\n------------------------\n\nReviving unbound methods would only solve a fraction of the problems this\nPEP solves, at a higher price (an additional object type and an additional\nindirection, rather than an additional attribute).\n\n\nNaming choice\n=============\n\n\"Qualified name\" is the best approximation, as a short phrase, of what the\nadditional attribute is about.  It is not a \"full name\" or \"fully qualified\nname\" since it (deliberately) does not include the module name.  Calling\nit a \"path\" would risk confusion with filesystem paths and the ``__file__``\nattribute.\n\nThe first proposal for the attribute name was to call it ``__qname__`` but\nmany people (who are not aware of previous use of such jargon in e.g. the\nXML specification [2]_) found it obscure and non-obvious, which is why the\nslightly less short and more explicit ``__qualname__`` was finally chosen.\n\n\nReferences\n==========\n\n.. [1] \"pickle should support methods\":\n   http://bugs.python.org/issue9276\n\n.. [2] \"QName\" entry in Wikipedia:\n   http://en.wikipedia.org/wiki/QName\n\n\nCopyright\n=========\n\nThis document has been placed in the public domain."
      },
      "diff": "@@ -158,15 +158,4 @@ References\n Copyright\n =========\n \n-This document has been placed in the public domain.\n-\n-\n-\n-..\n-   Local Variables:\n-   mode: indented-text\n-   indent-tabs-mode: nil\n-   sentence-end-double-space: t\n-   fill-column: 70\n-   coding: utf-8\n-   End:\n\\ No newline at end of file\n+This document has been placed in the public domain.\n\\ No newline at end of file"
    },
    {
      "diff_id": 2,
      "reason type": "Other",
      "reason text": "Removed the Content-Type: text/x-rst line from the document header as part of formatting/metadata cleanup; no substantive changes to the requirement content.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 3155\nTitle: Qualified name for classes and functions\nVersion: $Revision$\nLast-Modified: $Date$\nAuthor: Antoine Pitrou <solipsis@pitrou.net>\nStatus: Final\nType: Standards Track\nContent-Type: text/x-rst\nCreated: 29-Oct-2011\nPython-Version: 3.3\nPost-History:\nResolution: https://mail.python.org/pipermail/python-dev/2011-November/114545.html\n\n\nRationale\n=========\n\nPython's introspection facilities have long had poor support for\nnested classes.  Given a class object, it is impossible to know\nwhether it was defined inside another class or at module top-level;\nand, if the former, it is also impossible to know in which class it\nwas defined.  While use of nested classes is often considered poor\nstyle, the only reason for them to have second class introspection\nsupport is a lousy pun.\n\nPython 3 adds insult to injury by dropping what was formerly known as\nunbound methods.  In Python 2, given the following definition::\n\n    class C:\n        def f():\n            pass\n\nyou can then walk up from the ``C.f`` object to its defining class::\n\n    >>> C.f.im_class\n    <class '__main__.C'>\n\nThis possibility is gone in Python 3::\n\n    >>> C.f.im_class\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    AttributeError: 'function' object has no attribute 'im_class'\n    >>> dir(C.f)\n    ['__annotations__', '__call__', '__class__', '__closure__', '__code__',\n    '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__',\n    '__eq__', '__format__', '__ge__', '__get__', '__getattribute__',\n    '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__',\n    '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__',\n    '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',\n    '__str__', '__subclasshook__']\n\nThis limits again the introspection capabilities available to the\nuser.  It can produce actual issues when porting software to Python 3,\nfor example Twisted Core where the issue of introspecting method\nobjects came up several times.  It also limits pickling support [1]_.\n\n\nProposal\n========\n\nThis PEP proposes the addition of a ``__qualname__`` attribute to\nfunctions and classes.  For top-level functions and classes, the\n``__qualname__`` attribute is equal to the ``__name__`` attribute.  For\nnested classes, methods, and nested functions, the ``__qualname__``\nattribute contains a dotted path leading to the object from the module\ntop-level.  A function's local namespace is represented in that dotted\npath by a component named ``<locals>``.\n\nThe repr() and str() of functions and classes is modified to use\n``__qualname__`` rather than ``__name__``.\n\nExample with nested classes\n---------------------------\n\n>>> class C:\n...   def f(): pass\n...   class D:\n...     def g(): pass\n...\n>>> C.__qualname__\n'C'\n>>> C.f.__qualname__\n'C.f'\n>>> C.D.__qualname__\n'C.D'\n>>> C.D.g.__qualname__\n'C.D.g'\n\nExample with nested functions\n-----------------------------\n\n>>> def f():\n...   def g(): pass\n...   return g\n...\n>>> f.__qualname__\n'f'\n>>> f().__qualname__\n'f.<locals>.g'\n\n\nLimitations\n===========\n\nWith nested functions (and classes defined inside functions), the\ndotted path will not be walkable programmatically as a function's\nnamespace is not available from the outside.  It will still be more\nhelpful to the human reader than the bare ``__name__``.\n\nAs the ``__name__`` attribute, the ``__qualname__`` attribute is computed\nstatically and it will not automatically follow rebinding.\n\n\nDiscussion\n==========\n\nExcluding the module name\n-------------------------\n\nAs ``__name__``, ``__qualname__`` doesn't include the module name.  This\nmakes it independent of module aliasing and rebinding, and also allows to\ncompute it at compile time.\n\nReviving unbound methods\n------------------------\n\nReviving unbound methods would only solve a fraction of the problems this\nPEP solves, at a higher price (an additional object type and an additional\nindirection, rather than an additional attribute).\n\n\nNaming choice\n=============\n\n\"Qualified name\" is the best approximation, as a short phrase, of what the\nadditional attribute is about.  It is not a \"full name\" or \"fully qualified\nname\" since it (deliberately) does not include the module name.  Calling\nit a \"path\" would risk confusion with filesystem paths and the ``__file__``\nattribute.\n\nThe first proposal for the attribute name was to call it ``__qname__`` but\nmany people (who are not aware of previous use of such jargon in e.g. the\nXML specification [2]_) found it obscure and non-obvious, which is why the\nslightly less short and more explicit ``__qualname__`` was finally chosen.\n\n\nReferences\n==========\n\n.. [1] \"pickle should support methods\":\n   http://bugs.python.org/issue9276\n\n.. [2] \"QName\" entry in Wikipedia:\n   http://en.wikipedia.org/wiki/QName\n\n\nCopyright\n=========\n\nThis document has been placed in the public domain."
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 3155\nTitle: Qualified name for classes and functions\nVersion: $Revision$\nLast-Modified: $Date$\nAuthor: Antoine Pitrou <solipsis@pitrou.net>\nStatus: Final\nType: Standards Track\nCreated: 29-Oct-2011\nPython-Version: 3.3\nPost-History:\nResolution: https://mail.python.org/pipermail/python-dev/2011-November/114545.html\n\n\nRationale\n=========\n\nPython's introspection facilities have long had poor support for\nnested classes.  Given a class object, it is impossible to know\nwhether it was defined inside another class or at module top-level;\nand, if the former, it is also impossible to know in which class it\nwas defined.  While use of nested classes is often considered poor\nstyle, the only reason for them to have second class introspection\nsupport is a lousy pun.\n\nPython 3 adds insult to injury by dropping what was formerly known as\nunbound methods.  In Python 2, given the following definition::\n\n    class C:\n        def f():\n            pass\n\nyou can then walk up from the ``C.f`` object to its defining class::\n\n    >>> C.f.im_class\n    <class '__main__.C'>\n\nThis possibility is gone in Python 3::\n\n    >>> C.f.im_class\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    AttributeError: 'function' object has no attribute 'im_class'\n    >>> dir(C.f)\n    ['__annotations__', '__call__', '__class__', '__closure__', '__code__',\n    '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__',\n    '__eq__', '__format__', '__ge__', '__get__', '__getattribute__',\n    '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__',\n    '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__',\n    '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',\n    '__str__', '__subclasshook__']\n\nThis limits again the introspection capabilities available to the\nuser.  It can produce actual issues when porting software to Python 3,\nfor example Twisted Core where the issue of introspecting method\nobjects came up several times.  It also limits pickling support [1]_.\n\n\nProposal\n========\n\nThis PEP proposes the addition of a ``__qualname__`` attribute to\nfunctions and classes.  For top-level functions and classes, the\n``__qualname__`` attribute is equal to the ``__name__`` attribute.  For\nnested classes, methods, and nested functions, the ``__qualname__``\nattribute contains a dotted path leading to the object from the module\ntop-level.  A function's local namespace is represented in that dotted\npath by a component named ``<locals>``.\n\nThe repr() and str() of functions and classes is modified to use\n``__qualname__`` rather than ``__name__``.\n\nExample with nested classes\n---------------------------\n\n>>> class C:\n...   def f(): pass\n...   class D:\n...     def g(): pass\n...\n>>> C.__qualname__\n'C'\n>>> C.f.__qualname__\n'C.f'\n>>> C.D.__qualname__\n'C.D'\n>>> C.D.g.__qualname__\n'C.D.g'\n\nExample with nested functions\n-----------------------------\n\n>>> def f():\n...   def g(): pass\n...   return g\n...\n>>> f.__qualname__\n'f'\n>>> f().__qualname__\n'f.<locals>.g'\n\n\nLimitations\n===========\n\nWith nested functions (and classes defined inside functions), the\ndotted path will not be walkable programmatically as a function's\nnamespace is not available from the outside.  It will still be more\nhelpful to the human reader than the bare ``__name__``.\n\nAs the ``__name__`` attribute, the ``__qualname__`` attribute is computed\nstatically and it will not automatically follow rebinding.\n\n\nDiscussion\n==========\n\nExcluding the module name\n-------------------------\n\nAs ``__name__``, ``__qualname__`` doesn't include the module name.  This\nmakes it independent of module aliasing and rebinding, and also allows to\ncompute it at compile time.\n\nReviving unbound methods\n------------------------\n\nReviving unbound methods would only solve a fraction of the problems this\nPEP solves, at a higher price (an additional object type and an additional\nindirection, rather than an additional attribute).\n\n\nNaming choice\n=============\n\n\"Qualified name\" is the best approximation, as a short phrase, of what the\nadditional attribute is about.  It is not a \"full name\" or \"fully qualified\nname\" since it (deliberately) does not include the module name.  Calling\nit a \"path\" would risk confusion with filesystem paths and the ``__file__``\nattribute.\n\nThe first proposal for the attribute name was to call it ``__qname__`` but\nmany people (who are not aware of previous use of such jargon in e.g. the\nXML specification [2]_) found it obscure and non-obvious, which is why the\nslightly less short and more explicit ``__qualname__`` was finally chosen.\n\n\nReferences\n==========\n\n.. [1] \"pickle should support methods\":\n   http://bugs.python.org/issue9276\n\n.. [2] \"QName\" entry in Wikipedia:\n   http://en.wikipedia.org/wiki/QName\n\n\nCopyright\n=========\n\nThis document has been placed in the public domain."
      },
      "diff": "@@ -5,7 +5,6 @@ Last-Modified: $Date$\n Author: Antoine Pitrou <solipsis@pitrou.net>\n Status: Final\n Type: Standards Track\n-Content-Type: text/x-rst\n Created: 29-Oct-2011\n Python-Version: 3.3\n Post-History:"
    },
    {
      "diff_id": 3,
      "reason type": "Other",
      "reason text": "Removed the Last-Modified metadata line from the header; a boilerplate/metadata cleanup that does not change the requirement content or intended meaning.",
      "old_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 3155\nTitle: Qualified name for classes and functions\nVersion: $Revision$\nLast-Modified: $Date$\nAuthor: Antoine Pitrou <solipsis@pitrou.net>\nStatus: Final\nType: Standards Track\nCreated: 29-Oct-2011\nPython-Version: 3.3\nPost-History:\nResolution: https://mail.python.org/pipermail/python-dev/2011-November/114545.html\n\n\nRationale\n=========\n\nPython's introspection facilities have long had poor support for\nnested classes.  Given a class object, it is impossible to know\nwhether it was defined inside another class or at module top-level;\nand, if the former, it is also impossible to know in which class it\nwas defined.  While use of nested classes is often considered poor\nstyle, the only reason for them to have second class introspection\nsupport is a lousy pun.\n\nPython 3 adds insult to injury by dropping what was formerly known as\nunbound methods.  In Python 2, given the following definition::\n\n    class C:\n        def f():\n            pass\n\nyou can then walk up from the ``C.f`` object to its defining class::\n\n    >>> C.f.im_class\n    <class '__main__.C'>\n\nThis possibility is gone in Python 3::\n\n    >>> C.f.im_class\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    AttributeError: 'function' object has no attribute 'im_class'\n    >>> dir(C.f)\n    ['__annotations__', '__call__', '__class__', '__closure__', '__code__',\n    '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__',\n    '__eq__', '__format__', '__ge__', '__get__', '__getattribute__',\n    '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__',\n    '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__',\n    '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',\n    '__str__', '__subclasshook__']\n\nThis limits again the introspection capabilities available to the\nuser.  It can produce actual issues when porting software to Python 3,\nfor example Twisted Core where the issue of introspecting method\nobjects came up several times.  It also limits pickling support [1]_.\n\n\nProposal\n========\n\nThis PEP proposes the addition of a ``__qualname__`` attribute to\nfunctions and classes.  For top-level functions and classes, the\n``__qualname__`` attribute is equal to the ``__name__`` attribute.  For\nnested classes, methods, and nested functions, the ``__qualname__``\nattribute contains a dotted path leading to the object from the module\ntop-level.  A function's local namespace is represented in that dotted\npath by a component named ``<locals>``.\n\nThe repr() and str() of functions and classes is modified to use\n``__qualname__`` rather than ``__name__``.\n\nExample with nested classes\n---------------------------\n\n>>> class C:\n...   def f(): pass\n...   class D:\n...     def g(): pass\n...\n>>> C.__qualname__\n'C'\n>>> C.f.__qualname__\n'C.f'\n>>> C.D.__qualname__\n'C.D'\n>>> C.D.g.__qualname__\n'C.D.g'\n\nExample with nested functions\n-----------------------------\n\n>>> def f():\n...   def g(): pass\n...   return g\n...\n>>> f.__qualname__\n'f'\n>>> f().__qualname__\n'f.<locals>.g'\n\n\nLimitations\n===========\n\nWith nested functions (and classes defined inside functions), the\ndotted path will not be walkable programmatically as a function's\nnamespace is not available from the outside.  It will still be more\nhelpful to the human reader than the bare ``__name__``.\n\nAs the ``__name__`` attribute, the ``__qualname__`` attribute is computed\nstatically and it will not automatically follow rebinding.\n\n\nDiscussion\n==========\n\nExcluding the module name\n-------------------------\n\nAs ``__name__``, ``__qualname__`` doesn't include the module name.  This\nmakes it independent of module aliasing and rebinding, and also allows to\ncompute it at compile time.\n\nReviving unbound methods\n------------------------\n\nReviving unbound methods would only solve a fraction of the problems this\nPEP solves, at a higher price (an additional object type and an additional\nindirection, rather than an additional attribute).\n\n\nNaming choice\n=============\n\n\"Qualified name\" is the best approximation, as a short phrase, of what the\nadditional attribute is about.  It is not a \"full name\" or \"fully qualified\nname\" since it (deliberately) does not include the module name.  Calling\nit a \"path\" would risk confusion with filesystem paths and the ``__file__``\nattribute.\n\nThe first proposal for the attribute name was to call it ``__qname__`` but\nmany people (who are not aware of previous use of such jargon in e.g. the\nXML specification [2]_) found it obscure and non-obvious, which is why the\nslightly less short and more explicit ``__qualname__`` was finally chosen.\n\n\nReferences\n==========\n\n.. [1] \"pickle should support methods\":\n   http://bugs.python.org/issue9276\n\n.. [2] \"QName\" entry in Wikipedia:\n   http://en.wikipedia.org/wiki/QName\n\n\nCopyright\n=========\n\nThis document has been placed in the public domain."
      },
      "new_version": {
        "version id": 4,
        "requirement id": 0,
        "content": "PEP: 3155\nTitle: Qualified name for classes and functions\nVersion: $Revision$\nAuthor: Antoine Pitrou <solipsis@pitrou.net>\nStatus: Final\nType: Standards Track\nCreated: 29-Oct-2011\nPython-Version: 3.3\nPost-History:\nResolution: https://mail.python.org/pipermail/python-dev/2011-November/114545.html\n\n\nRationale\n=========\n\nPython's introspection facilities have long had poor support for\nnested classes.  Given a class object, it is impossible to know\nwhether it was defined inside another class or at module top-level;\nand, if the former, it is also impossible to know in which class it\nwas defined.  While use of nested classes is often considered poor\nstyle, the only reason for them to have second class introspection\nsupport is a lousy pun.\n\nPython 3 adds insult to injury by dropping what was formerly known as\nunbound methods.  In Python 2, given the following definition::\n\n    class C:\n        def f():\n            pass\n\nyou can then walk up from the ``C.f`` object to its defining class::\n\n    >>> C.f.im_class\n    <class '__main__.C'>\n\nThis possibility is gone in Python 3::\n\n    >>> C.f.im_class\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    AttributeError: 'function' object has no attribute 'im_class'\n    >>> dir(C.f)\n    ['__annotations__', '__call__', '__class__', '__closure__', '__code__',\n    '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__',\n    '__eq__', '__format__', '__ge__', '__get__', '__getattribute__',\n    '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__',\n    '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__',\n    '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',\n    '__str__', '__subclasshook__']\n\nThis limits again the introspection capabilities available to the\nuser.  It can produce actual issues when porting software to Python 3,\nfor example Twisted Core where the issue of introspecting method\nobjects came up several times.  It also limits pickling support [1]_.\n\n\nProposal\n========\n\nThis PEP proposes the addition of a ``__qualname__`` attribute to\nfunctions and classes.  For top-level functions and classes, the\n``__qualname__`` attribute is equal to the ``__name__`` attribute.  For\nnested classes, methods, and nested functions, the ``__qualname__``\nattribute contains a dotted path leading to the object from the module\ntop-level.  A function's local namespace is represented in that dotted\npath by a component named ``<locals>``.\n\nThe repr() and str() of functions and classes is modified to use\n``__qualname__`` rather than ``__name__``.\n\nExample with nested classes\n---------------------------\n\n>>> class C:\n...   def f(): pass\n...   class D:\n...     def g(): pass\n...\n>>> C.__qualname__\n'C'\n>>> C.f.__qualname__\n'C.f'\n>>> C.D.__qualname__\n'C.D'\n>>> C.D.g.__qualname__\n'C.D.g'\n\nExample with nested functions\n-----------------------------\n\n>>> def f():\n...   def g(): pass\n...   return g\n...\n>>> f.__qualname__\n'f'\n>>> f().__qualname__\n'f.<locals>.g'\n\n\nLimitations\n===========\n\nWith nested functions (and classes defined inside functions), the\ndotted path will not be walkable programmatically as a function's\nnamespace is not available from the outside.  It will still be more\nhelpful to the human reader than the bare ``__name__``.\n\nAs the ``__name__`` attribute, the ``__qualname__`` attribute is computed\nstatically and it will not automatically follow rebinding.\n\n\nDiscussion\n==========\n\nExcluding the module name\n-------------------------\n\nAs ``__name__``, ``__qualname__`` doesn't include the module name.  This\nmakes it independent of module aliasing and rebinding, and also allows to\ncompute it at compile time.\n\nReviving unbound methods\n------------------------\n\nReviving unbound methods would only solve a fraction of the problems this\nPEP solves, at a higher price (an additional object type and an additional\nindirection, rather than an additional attribute).\n\n\nNaming choice\n=============\n\n\"Qualified name\" is the best approximation, as a short phrase, of what the\nadditional attribute is about.  It is not a \"full name\" or \"fully qualified\nname\" since it (deliberately) does not include the module name.  Calling\nit a \"path\" would risk confusion with filesystem paths and the ``__file__``\nattribute.\n\nThe first proposal for the attribute name was to call it ``__qname__`` but\nmany people (who are not aware of previous use of such jargon in e.g. the\nXML specification [2]_) found it obscure and non-obvious, which is why the\nslightly less short and more explicit ``__qualname__`` was finally chosen.\n\n\nReferences\n==========\n\n.. [1] \"pickle should support methods\":\n   http://bugs.python.org/issue9276\n\n.. [2] \"QName\" entry in Wikipedia:\n   http://en.wikipedia.org/wiki/QName\n\n\nCopyright\n=========\n\nThis document has been placed in the public domain."
      },
      "diff": "@@ -1,7 +1,6 @@\n PEP: 3155\n Title: Qualified name for classes and functions\n Version: $Revision$\n-Last-Modified: $Date$\n Author: Antoine Pitrou <solipsis@pitrou.net>\n Status: Final\n Type: Standards Track"
    },
    {
      "diff_id": 4,
      "reason type": "Deletion",
      "reason text": "Removed the Version line (Version: $Revision$) from the header in the New Version; this metadata was redundant and not part of the formal requirement content.",
      "old_version": {
        "version id": 4,
        "requirement id": 0,
        "content": "PEP: 3155\nTitle: Qualified name for classes and functions\nVersion: $Revision$\nAuthor: Antoine Pitrou <solipsis@pitrou.net>\nStatus: Final\nType: Standards Track\nCreated: 29-Oct-2011\nPython-Version: 3.3\nPost-History:\nResolution: https://mail.python.org/pipermail/python-dev/2011-November/114545.html\n\n\nRationale\n=========\n\nPython's introspection facilities have long had poor support for\nnested classes.  Given a class object, it is impossible to know\nwhether it was defined inside another class or at module top-level;\nand, if the former, it is also impossible to know in which class it\nwas defined.  While use of nested classes is often considered poor\nstyle, the only reason for them to have second class introspection\nsupport is a lousy pun.\n\nPython 3 adds insult to injury by dropping what was formerly known as\nunbound methods.  In Python 2, given the following definition::\n\n    class C:\n        def f():\n            pass\n\nyou can then walk up from the ``C.f`` object to its defining class::\n\n    >>> C.f.im_class\n    <class '__main__.C'>\n\nThis possibility is gone in Python 3::\n\n    >>> C.f.im_class\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    AttributeError: 'function' object has no attribute 'im_class'\n    >>> dir(C.f)\n    ['__annotations__', '__call__', '__class__', '__closure__', '__code__',\n    '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__',\n    '__eq__', '__format__', '__ge__', '__get__', '__getattribute__',\n    '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__',\n    '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__',\n    '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',\n    '__str__', '__subclasshook__']\n\nThis limits again the introspection capabilities available to the\nuser.  It can produce actual issues when porting software to Python 3,\nfor example Twisted Core where the issue of introspecting method\nobjects came up several times.  It also limits pickling support [1]_.\n\n\nProposal\n========\n\nThis PEP proposes the addition of a ``__qualname__`` attribute to\nfunctions and classes.  For top-level functions and classes, the\n``__qualname__`` attribute is equal to the ``__name__`` attribute.  For\nnested classes, methods, and nested functions, the ``__qualname__``\nattribute contains a dotted path leading to the object from the module\ntop-level.  A function's local namespace is represented in that dotted\npath by a component named ``<locals>``.\n\nThe repr() and str() of functions and classes is modified to use\n``__qualname__`` rather than ``__name__``.\n\nExample with nested classes\n---------------------------\n\n>>> class C:\n...   def f(): pass\n...   class D:\n...     def g(): pass\n...\n>>> C.__qualname__\n'C'\n>>> C.f.__qualname__\n'C.f'\n>>> C.D.__qualname__\n'C.D'\n>>> C.D.g.__qualname__\n'C.D.g'\n\nExample with nested functions\n-----------------------------\n\n>>> def f():\n...   def g(): pass\n...   return g\n...\n>>> f.__qualname__\n'f'\n>>> f().__qualname__\n'f.<locals>.g'\n\n\nLimitations\n===========\n\nWith nested functions (and classes defined inside functions), the\ndotted path will not be walkable programmatically as a function's\nnamespace is not available from the outside.  It will still be more\nhelpful to the human reader than the bare ``__name__``.\n\nAs the ``__name__`` attribute, the ``__qualname__`` attribute is computed\nstatically and it will not automatically follow rebinding.\n\n\nDiscussion\n==========\n\nExcluding the module name\n-------------------------\n\nAs ``__name__``, ``__qualname__`` doesn't include the module name.  This\nmakes it independent of module aliasing and rebinding, and also allows to\ncompute it at compile time.\n\nReviving unbound methods\n------------------------\n\nReviving unbound methods would only solve a fraction of the problems this\nPEP solves, at a higher price (an additional object type and an additional\nindirection, rather than an additional attribute).\n\n\nNaming choice\n=============\n\n\"Qualified name\" is the best approximation, as a short phrase, of what the\nadditional attribute is about.  It is not a \"full name\" or \"fully qualified\nname\" since it (deliberately) does not include the module name.  Calling\nit a \"path\" would risk confusion with filesystem paths and the ``__file__``\nattribute.\n\nThe first proposal for the attribute name was to call it ``__qname__`` but\nmany people (who are not aware of previous use of such jargon in e.g. the\nXML specification [2]_) found it obscure and non-obvious, which is why the\nslightly less short and more explicit ``__qualname__`` was finally chosen.\n\n\nReferences\n==========\n\n.. [1] \"pickle should support methods\":\n   http://bugs.python.org/issue9276\n\n.. [2] \"QName\" entry in Wikipedia:\n   http://en.wikipedia.org/wiki/QName\n\n\nCopyright\n=========\n\nThis document has been placed in the public domain."
      },
      "new_version": {
        "version id": 5,
        "requirement id": 0,
        "content": "PEP: 3155\nTitle: Qualified name for classes and functions\nAuthor: Antoine Pitrou <solipsis@pitrou.net>\nStatus: Final\nType: Standards Track\nCreated: 29-Oct-2011\nPython-Version: 3.3\nPost-History:\nResolution: https://mail.python.org/pipermail/python-dev/2011-November/114545.html\n\n\nRationale\n=========\n\nPython's introspection facilities have long had poor support for\nnested classes.  Given a class object, it is impossible to know\nwhether it was defined inside another class or at module top-level;\nand, if the former, it is also impossible to know in which class it\nwas defined.  While use of nested classes is often considered poor\nstyle, the only reason for them to have second class introspection\nsupport is a lousy pun.\n\nPython 3 adds insult to injury by dropping what was formerly known as\nunbound methods.  In Python 2, given the following definition::\n\n    class C:\n        def f():\n            pass\n\nyou can then walk up from the ``C.f`` object to its defining class::\n\n    >>> C.f.im_class\n    <class '__main__.C'>\n\nThis possibility is gone in Python 3::\n\n    >>> C.f.im_class\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    AttributeError: 'function' object has no attribute 'im_class'\n    >>> dir(C.f)\n    ['__annotations__', '__call__', '__class__', '__closure__', '__code__',\n    '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__',\n    '__eq__', '__format__', '__ge__', '__get__', '__getattribute__',\n    '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__',\n    '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__',\n    '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',\n    '__str__', '__subclasshook__']\n\nThis limits again the introspection capabilities available to the\nuser.  It can produce actual issues when porting software to Python 3,\nfor example Twisted Core where the issue of introspecting method\nobjects came up several times.  It also limits pickling support [1]_.\n\n\nProposal\n========\n\nThis PEP proposes the addition of a ``__qualname__`` attribute to\nfunctions and classes.  For top-level functions and classes, the\n``__qualname__`` attribute is equal to the ``__name__`` attribute.  For\nnested classes, methods, and nested functions, the ``__qualname__``\nattribute contains a dotted path leading to the object from the module\ntop-level.  A function's local namespace is represented in that dotted\npath by a component named ``<locals>``.\n\nThe repr() and str() of functions and classes is modified to use\n``__qualname__`` rather than ``__name__``.\n\nExample with nested classes\n---------------------------\n\n>>> class C:\n...   def f(): pass\n...   class D:\n...     def g(): pass\n...\n>>> C.__qualname__\n'C'\n>>> C.f.__qualname__\n'C.f'\n>>> C.D.__qualname__\n'C.D'\n>>> C.D.g.__qualname__\n'C.D.g'\n\nExample with nested functions\n-----------------------------\n\n>>> def f():\n...   def g(): pass\n...   return g\n...\n>>> f.__qualname__\n'f'\n>>> f().__qualname__\n'f.<locals>.g'\n\n\nLimitations\n===========\n\nWith nested functions (and classes defined inside functions), the\ndotted path will not be walkable programmatically as a function's\nnamespace is not available from the outside.  It will still be more\nhelpful to the human reader than the bare ``__name__``.\n\nAs the ``__name__`` attribute, the ``__qualname__`` attribute is computed\nstatically and it will not automatically follow rebinding.\n\n\nDiscussion\n==========\n\nExcluding the module name\n-------------------------\n\nAs ``__name__``, ``__qualname__`` doesn't include the module name.  This\nmakes it independent of module aliasing and rebinding, and also allows to\ncompute it at compile time.\n\nReviving unbound methods\n------------------------\n\nReviving unbound methods would only solve a fraction of the problems this\nPEP solves, at a higher price (an additional object type and an additional\nindirection, rather than an additional attribute).\n\n\nNaming choice\n=============\n\n\"Qualified name\" is the best approximation, as a short phrase, of what the\nadditional attribute is about.  It is not a \"full name\" or \"fully qualified\nname\" since it (deliberately) does not include the module name.  Calling\nit a \"path\" would risk confusion with filesystem paths and the ``__file__``\nattribute.\n\nThe first proposal for the attribute name was to call it ``__qname__`` but\nmany people (who are not aware of previous use of such jargon in e.g. the\nXML specification [2]_) found it obscure and non-obvious, which is why the\nslightly less short and more explicit ``__qualname__`` was finally chosen.\n\n\nReferences\n==========\n\n.. [1] \"pickle should support methods\":\n   http://bugs.python.org/issue9276\n\n.. [2] \"QName\" entry in Wikipedia:\n   http://en.wikipedia.org/wiki/QName\n\n\nCopyright\n=========\n\nThis document has been placed in the public domain."
      },
      "diff": "@@ -1,6 +1,5 @@\n PEP: 3155\n Title: Qualified name for classes and functions\n-Version: $Revision$\n Author: Antoine Pitrou <solipsis@pitrou.net>\n Status: Final\n Type: Standards Track"
    }
  ]
}