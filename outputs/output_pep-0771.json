{
  "domain": "peps/pep-0771.rst",
  "number of versions": 4,
  "diffs": [
    {
      "diff_id": 1,
      "reason type": "Other",
      "reason text": "The changes are editorial/metadata edits to the document header (added Discussions-To and Post-History lines) and do not modify the requirements themselves (no change to intent, constraints, or semantics). This is not a requirement-level change.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "Title: Default Extras for Python Software Packages\n Author: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\n Sponsor: Pradyun Gedam <pradyunsg@gmail.com>\n+Discussions-To: https://discuss.python.org/t/79706/\n Status: Draft\n Type: Standards Track\n Topic: Packaging\n Created: 13-Jan-2025\n+Post-History:\n+  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n+  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n \n Abstract\n ========",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 2,
      "reason type": "Demonstration",
      "reason text": "Added Examples of packages that demonstrate this pattern by encouraging users to include extra dependencies by default (astropy, fastapi, tensorflow) to illustrate the recommended dependencies default behavior.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "of the ``[recommended]`` syntax, placing the burden on them to know this for a\n typical installation. Having a way to have recommended dependencies be installed\n by default while providing a way for users to request a more minimal installation\n-would satisfy this use case. The present PEP will describe a solution for this use case.\n+would satisfy this use case, and this PEP describes a solution to this.\n+\n+Examples of packages that demonstrate this pattern by encouraging users to\n+include extra dependencies by default include:\n+\n+* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n+* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n+* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n \n Packages supporting multiple backends or frontends\n --------------------------------------------------",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 3,
      "reason type": "Clarification",
      "reason text": "This change is a Clarification: the underlying requirement remains the same (to introduce a Default-Extra mechanism to install default extras when none are specified). The New version mostly revises wording, adds references and examples, and renames the project metadata key from default-optional-dependencies to default-optional-dependency-keys for clarity. It does not introduce new functionality or alter the fundamental behavior; it clarifies usage and provides additional contextual materials.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "in order to be functional, but may be flexible on which backend or frontend this\n is. Concrete examples of such frontends or backends include:\n \n-* The Qt frontend library, which requires either PySide or PyQt to be installed\n+* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n+  <https://pypi.org/project/PyQt6/>`_, `PySide2\n+  <https://pypi.org/project/PySide2/>`_, or `PySide6\n+  <https://pypi.org/project/PySide6/>`_\n * BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n * FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 4,
      "reason type": "Meaning",
      "reason text": "The most significant change is a semantic/structural update: the [project] metadata key for default extras is renamed from default-optional-dependencies to default-optional-dependency-keys, and the accompanying example TOML uses the new key. This changes the required metadata field and its usage. Additionally, the diff adds demonstrative content (examples of packages requiring a backend/frontend, e.g., kivy/napari/glueviz) and updates the rationale with a new bullet about re-using the syntax from :pep:`508` and a corrected thread link, but these are supplementary clarifications and examples rather than core intent changes.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "infrastructure to disallow conflicting or incompatible extras to be installed,\n and this PEP does not change that.\n \n+Examples of packages that require at least one backend or frontend to work and\n+recommend a default extra to install a backend or frontend include:\n+\n+* `kivy <https://kivy.org/>`_: ``kivy[base]``\n+\n+* `napari <https://napari.org>`_: ``napari[all]``\n+\n+* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n+\n+In all three cases, installing the package without any extras results in a\n+broken installation (and this is a commonly reported issue for some of these\n+packages).\n+\n Rationale\n =========\n \n A number of possible solutions have been extensively and vigorously discussed by\n the community for several years, including in `this DPO thread\n-<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\n-as well as in numerous issues and pull requests. The solution that will be\n+<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\n+as well as in numerous issues and pull requests. The solution that is\n presented below:\n \n-* does not break backward-compatibility of existing packaging infrastructure\n * is an opt-in solution which means that package maintainers can choose whether or not to use it\n-* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n+* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n+* re-uses the syntax from :pep:`508`\n \n It is the only solution out of all those discussed that meets all three criteria.",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 5,
      "reason type": "Clarification",
      "reason text": "The change is a rename of the [project] metadata key from 'default-optional-dependencies' to 'default-optional-dependency-keys'. The underlying meaning remains the same (a list of extras that map to Default-Extra); this is a terminology normalization/clarification rather than a change in behavior, so the dominant change is clarifying the naming rather than introducing new requirements.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "A new key will be added to the ``[project]`` table in project metadata as\n originally defined in :pep:`621` and now defined in the `PyPA specifications\n <https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n-``default-optional-dependencies`` with the following description:\n+``default-optional-dependency-keys`` with the following description:\n \n * `TOML <https://toml.io/>`_ type: Array of strings\n * Corresponding core metadata field: ``Default-Extra``\n \n-Each string in ``default-optional-dependencies`` must be the name of an extra\n+Each string in ``default-optional-dependency-keys`` must be the name of an extra\n defined in `optional-dependencies\n <https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\n and each extra in this array will be converted to a matching ``Default-Extra``",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 6,
      "reason type": "Clarification",
      "reason text": "Renamed the [project] key from default-optional-dependencies to default-optional-dependency-keys to reflect that the values are the names/keys of extras (not actual dependencies). The semantics remain the same (each string corresponds to an extra and maps to Default-Extra).",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": ".. code-block:: toml\n \n     [project]\n-    default-optional-dependencies = [\n+    default-optional-dependency-keys = [\n         \"recommended\",\n     ]",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 7,
      "reason type": "Clarification",
      "reason text": "Renamed the [project] metadata field from default-optional-dependencies to default-optional-dependency-keys to reflect that the value is a list of extra-names (keys) rather than dependencies. The new name clarifies the semantics and aligns terminology with the concept of extras defined in optional-dependencies, preserving behavior while improving clarity.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": ".. code-block:: toml\n \n     [project]\n-    default-optional-dependencies = [\n+    default-optional-dependency-keys = [\n         \"backend1\",\n         \"backend2\",\n         \"backend3\"",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 8,
      "reason type": "Clarification",
      "reason text": "The changes are primarily editorial refinements and expansions of the existing proposal rather than introducing a new requirement. The update adds clarifying elements (Discussions-To, Post-History), expands motivation and examples, and rephrases sections for readability, while preserving the overall intent and backward compatibility of the original PEP. A metadata-key naming adjustment appears in the text but serves to clarify terminology rather than to introduce a new behavior; the dominant effect is clarifying and tightening the existing requirements rather than changing their meaning.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "-------------------------\n \n If extras are explicitly given in a dependency specification, the default\n-extras are not installed. Otherwise, the default extras are used.\n+extras are ignored. Otherwise, the default extras are installed.\n+\n+For example, if a package defines an ``extra1`` default extra as well as a\n+non-default ``extra2`` extra, then if a user were to install the package with:\n+\n+.. code-block:: console\n \n-For example, if a package\n-defines an ``extra1`` default extra as well as a non-default ``extra2``\n-extra, then if a user were to install the package with::\n+    $ pip install package\n \n-    pip install package\n+the default ``extra1`` dependency would be included. If the user instead\n+installs the package with:\n \n-the ``extra1`` dependency would be included. If the user instead uses::\n+.. code-block:: console\n \n-    pip install package[extra2]\n+    $ pip install package[extra2]\n \n-then the ``extra1`` extra would not be installed.\n+then the ``extra2`` extra would be installed but the default ``extra1`` extra\n+would be ignored.\n \n If the same package is specified multiple times in an installation command or\n dependency tree, the default extras must be installed if any of the instances of\n-the package are specified without extras. For instance::\n+the package are specified without extras.  For instance, if one installs a\n+package ``spam`` where ``package`` appears several times in the dependency\n+tree::\n \n-    pip install package package[extra2]\n+    spam\n+    \u251c\u2500\u2500 tomato\n+    \u2502   \u251c\u2500\u2500 package[extra2]\n+    \u2514\u2500\u2500 egg\n+        \u2514\u2500\u2500 package\n \n-should install the default extras.\n+then the default extra should be installed because ``package`` appears at least\n+once with no extras specified.\n \n Note that ``package[]`` would continue to be equivalent to ``package`` and would\n not be provided as a way to install without default extras (see the `Rejected\n Ideas`_ section for the rationale).\n \n+We also note that some tools such as `pip`_ currently ignore unrecognized\n+extras, and emit a warning to the user to indicate that the extra has not been\n+recognized, e.g:\n+\n+.. code-block:: console\n+\n+    $ pip install package[non-existent-extra]\n+    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n+    ...\n+\n+For tools that behave like this (rather than raising an error), if an extra is\n+recognized as invalid in a dependency specification, it should be ignored and\n+treated as if the user has not passed an explicit extra. If none of the provided\n+extras are valid, default extras should be installed.\n+\n Installing without default extras\n ---------------------------------\n \n In some cases, package maintainers may want to facilitate installing packages\n without any default extras. In this case, as will be shown in more detail in\n-`How to teach this`_, the best approach is to define an extra which could be\n+`Examples`_, the best approach is to define an extra which could be\n called e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\n maintainer) which would be an empty set of dependencies. If this extra is\n specified, no default extras will be included, so that e.g. ``package[minimal]``",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 9,
      "reason type": "Clarification",
      "reason text": "Added an opening statement to the next section.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "therefore not want to provide an option to install the package without any\n extras.\n \n-Backward Compatibility\n-======================\n+Examples\n+--------\n \n-All package specification cases valid under :pep:`508` will remain valid.\n-Therefore, this proposal is fully backward-compatible with existing :pep:`508`\n-usage.\n-\n-Once packages start defining default extras, those defaults will only be honored\n-with recent versions of packaging tools which implement this PEP, but those\n-packages will remain fully backward-compatible with older packaging tools - with\n-the only difference that the default extras will not be installed automatically\n-when older packaging tools are used.\n-\n-The only conceptual backward-compatibility issue to consider is the fact that\n-this PEP changes extras to no longer be strictly additive, in that specifying\n-an extra such as ``minimal`` could result in fewer packages being installed.\n-\n-Security Implications\n-=====================\n-\n-There are no known security implications for this PEP.\n-\n-How to teach this\n-=================\n-\n-The rule above regarding only installing default extras when no extras\n-are explicitly specified, combined with the introduction of the\n-``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\n-allows us to address several different use cases. Below we take a look at the\n-two specific use cases raised in the `Motivation`_ section and how package\n-maintainers should be taught to address these.\n+In this section we take a look at the use cases described in the `Motivation`_\n+section and how these can now be addressed by using the specification outlined\n+above.\n \n Recommended dependencies and minimal installations\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n First, we consider the case of packages that want recommended\n but not strictly required dependencies installed by default, while also",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 10,
      "reason type": "Clarification",
      "reason text": "Renaming of a metadata field in the [project] section from default-optional-dependencies to default-optional-dependency-keys. The change affects only the field name; the semantics remain the same (a list of default extras), so this is a naming clarification rather than new functionality.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": ".. code-block:: toml\n \n     [project]\n-    default-optional-dependencies = [\n+    default-optional-dependency-keys = [\n         \"recommended\"\n     ]",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 11,
      "reason type": "Demonstration",
      "reason text": "The diff adds a concrete demonstration/example showing how default extras would work (using astropy as a case study, with a default 'recommended' extra and a new 'minimal' extra, including TOML configuration and pip install commands). This is purely illustrative to aid understanding and does not change the requirement's intent or behavior.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "minimal installation or not - in some cases, such as highlighted in the next\n section, this might not be desirable.\n \n+To take a one of the concrete examples of package from the `Motivation`_\n+section, the `astropy`_ package defines a ``recommended`` extra that users are\n+currently instructed to install in the default installation instructions.\n+With this PEP, the ``recommended`` extra could be declared as being a default\n+extra, and a new ``minimal`` extra could be provided for users wishing to\n+retain the ability to install only the strictly required dependencies:\n+\n+.. code-block:: toml\n+\n+    [project]\n+    default-optional-dependency-keys = [\n+        \"recommended\"\n+    ]\n+\n+    [project.optional-dependencies]\n+    minimal = []\n+    recommended = [\n+        \"scipy\",\n+        \"...\"\n+    ]\n+\n+meaning that installing:\n+\n+.. code-block:: console\n+\n+    $ pip install astropy\n+\n+would then also install optional but important optional dependencies such as `scipy\n+<https://www.scipy.org>`_. Advanced users who want a minimal\n+install could then use:\n+\n+.. code-block:: console\n+\n+    $ pip install astropy[minimal]\n+\n+\n Packages requiring at least one backend or frontend\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n As described in `Motivation`_, some packages may support multiple backends\n and/or frontends, and in some cases it may be desirable to ensure that there",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 12,
      "reason type": "Clarification",
      "reason text": "The change from 'default-optional-dependencies' to 'default-optional-dependency-keys' is editorial, changing the metadata field name; the underlying concept\u2014defining a default set of extras that applies when no extras are specified\u2014remains the same. This is a clarification/renaming for consistency and precision, not a new requirement or a change in behavior.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": ".. code-block:: toml\n \n     [project]\n-    default-optional-dependencies = [\n+    default-optional-dependency-keys = [\n         \"backend1\"\n     ]",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 13,
      "reason type": "Demonstration",
      "reason text": "A concrete napari example was added to illustrate how default-optional-dependency-keys and project.optional-dependencies could be configured to enable default frontend backends (PyQt5/6, PySide2/6). This demonstrates the concept in practice but does not introduce new requirements or change the underlying intent; it serves as a practical demonstration of the existing proposal.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "the backends should always be installed, then the dependencies for these must be given\n as required dependencies rather than using the default extras mechanism.\n \n+To take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\n+can make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\n+need to explicitly specify ``napari[all]`` in order to have one of these be installed,\n+or e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n+``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\n+could define the following configuration:\n+\n+.. code-block:: toml\n+\n+    [project]\n+    default-optional-dependency-keys = [\n+        \"pyqt5\"\n+    ]\n+\n+    [project.optional-dependencies]\n+    pyqt5 = [\n+        \"PyQt5\",\n+        \"...\"\n+    ]\n+    pyside2 = [\n+        \"PySide2\",\n+        \"...\"\n+    ]\n+    pyqt6 = [\n+        \"PyQt6\",\n+        \"...\"\n+    ]\n+    pyside6 = [\n+        \"PySide6\",\n+        \"...\"\n+    ]\n+\n+meaning that:\n+\n+.. code-block:: console\n+\n+    $ pip install napari\n+\n+would work out-of-the-box, but there would still be a mechanism for users to\n+explicitly specify a frontend, e.g.:\n+\n+.. code-block:: console\n+\n+    $ pip install napari[pyside6]\n+\n Supporting minimal installations while not always removing default extras\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n An additional case we consider here is where a package maintainer wants to support\n minimal installations without any extras, but also wants to support having users",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 14,
      "reason type": "Clarification",
      "reason text": "The primary change in the diff is a renaming of the [project] metadata key from default-optional-dependencies to default-optional-dependency-keys (and related wording). This alters the exact identifier used in the specification but does not introduce new requirements or behavior; it clarifies the terminology to reflect that the value is a list of extra-key names (dependency keys) rather than literal dependencies, and aligns surrounding text accordingly. In short, it's a naming/clarification change, not a functional addition or correction.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": ".. code-block:: toml\n \n     [project]\n-    default-optional-dependencies = [\n+    default-optional-dependency-keys = [\n         \"recommended\"\n     ]",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 15,
      "reason type": "Meaning",
      "reason text": "The changes introduce a substantial revision of the guidance around default extras: the section formerly titled 'Teaching package authors' is expanded with concrete examples (e.g., astropy) and new install paths, including 'Users installing' and explicit TOML/console examples. Additionally, new subsections 'Backward Compatibility' and 'Packaging-related tools' are added, shifting the surrounding discussion toward compatibility implications and tooling behavior. Most importantly, the TOML key name used to configure default extras changes from default-optional-dependencies to default-optional-dependency-keys, effectively altering how packages declare default extras via pyproject metadata. Together, these changes modify the meaning/intent of the default-extras mechanism and its adoption guidance, not merely fix typos or summarize existing text.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "The ability for a package to reference itself in the extras is supported by\n existing Python packaging tools.\n \n-Teaching package authors\n+Once again considering a concrete example, `astropy`_ could with this PEP define a\n+``recommended`` extra (as described in `Recommended dependencies and minimal\n+installations`_). However, it also defines other extras, including for example\n+``jupyter``, which adds packages that\n+enhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\n+environments. It is possible that users opting in to this extra would still want\n+recommended dependencies to be installed. In this case, the following\n+configuration would solve this case:\n+\n+.. code-block:: toml\n+\n+    [project]\n+    default-optional-dependency-keys = [\n+        \"recommended\"\n+    ]\n+\n+    [project.optional-dependencies]\n+    minimal = []\n+    recommended = [\n+        \"scipy\",\n+        \"...\"\n+    ]\n+    jupyter = [\n+        \"astropy[recommended]\",\n+        \"ipywidgets\",\n+        \"...\"\n+    ]\n+\n+Users installing:\n+\n+.. code-block:: console\n+\n+    $ pip install astropy[jupyter]\n+\n+would then get the same as:\n+\n+.. code-block:: console\n+\n+    $ pip install astropy[recommended, jupyter]\n+\n+\n+Backward Compatibility\n+======================\n+\n+Packages not using default extras\n+---------------------------------\n+\n+Once support for this PEP is added to tools in the packaging ecosystem, packages\n+that do not make use of default extras will continue to work as-is and there\n+should be no break in compatibility.\n+\n+Packages using default extras\n+-----------------------------\n+\n+Once packages start defining default extras, those defaults will only be honored\n+with recent versions of packaging tools which implement this PEP, but those\n+packages will remain installable with older packaging tools -- with the main\n+difference being that the default extras will not be installed automatically\n+when older packaging tools are used.\n+\n+As described in `How to teach this`_,\n+package authors need to carefully evaluate when and how they adopt\n+the default extra feature depending on their user base, as some actions (such as\n+moving a required dependency to a default extra) will likely result in breakage\n+for users if a significant fraction of them are still using older package\n+installers that do not support default extras. In this sense, package authors\n+should be aware that this feature, if used in certain ways, can cause\n+backward-compatibility issues for users, and they are thus responsible for\n+ensuring that they minimize the impact to users.\n \n-Packages making use of any of the approaches above must ensure that they\n-properly document the options available to users in terms of installation.\n+Packaging-related tools\n+-----------------------\n+\n+The most significant backward-compatibility aspect is related to assumptions\n+packaging tools make about extras -- specifically, this PEP changes the\n+assumption that extras are no longer exclusively additive in terms of adding\n+dependencies to the dependency tree, and specifying some extras can result in\n+fewer dependencies being installed.\n+\n+A specific example of change in behavior can be seen with `pip`_: consider a\n+package ``package`` which has a required dependency of ``numpy``, a (default)\n+extra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\n+which does not contain any dependencies. If a user installs ``package[minimal]``,\n+only ``package`` and ``numpy`` will be installed. If a user then does:\n+\n+.. code-block:: console\n+\n+    $ pip freeze > requirements.txt\n+\n+then ``requirements.txt`` will contain e.g.::\n+\n+    package==1.0.2\n+    numpy==2.1.0\n+\n+However, if the user then installs the requirements from this file using:\n+\n+.. code-block:: console\n+\n+    $ pip install -r requirements.txt\n+\n+then pip will install ``package`` (which will include the default extra) as well\n+as ``numpy``, so the final environment will contain ``scipy``. A solution in this\n+specific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\n+resolving the dependency tree, but the point here is to illustrate that there\n+may be changes in behavior in packaging tools due to the change in the\n+assumption about what impact an extra can have.\n+\n+Security Implications\n+=====================\n+\n+There are no known security implications for this PEP.\n+\n+How to teach this\n+=================\n+\n+This section outlines information that should be made available to people in\n+different groups in the community in relation to the implementation of this PEP.\n+Some aspects described below will be relevant even before the PEP is fully\n+implemented in packaging tools as there are some preparations that can be done\n+in advance of this implementation to facilitate any potential transition later\n+on. The groups covered below are:\n+\n+- `Package end users`_\n+- `Package authors`_\n+- `Packaging repository maintainers`_\n+\n+Package end users\n+-----------------\n+\n+Package users should be provided with clear installation instructions that show\n+what extras are available for packages and how they behave, for example\n+explaining that by default some recommended dependencies or a given frontend or\n+backend will be installed, and how to opt out of this or override defaults,\n+depending what is available.\n+\n+Package authors\n+---------------\n+\n+While the mechanism used to define extras and the associated rule about when to\n+use it are clear, package authors need to carefully consider several points\n+before adopting this capability in their packages, to avoid inadvertently breaking\n+backward-compatibility.\n+\n+Supporting older versions of package installers\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+Package installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\n+necessarily implement support for default extras at the same time, and once they\n+do it is likely that package authors will want to keep supporting users who do\n+not have the most recent version of a package installer. In this case, the\n+following recommendations would apply:\n+\n+* Moving a package from being a required dependency to a default extra would be\n+  a breaking change, because older versions of package installers would not\n+  recognise the concept of default extras, and would then install the package\n+  with fewer dependencies, which could affect users that would have been relying\n+  on these. Therefore, changing dependencies from required to a default extra in\n+  an established package should only be done in future once the developers only\n+  want to support users with installers that implement this PEP.\n+\n+* Making an existing extra become a default should be safer, such as making\n+  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n+  with older versions of package installers, the documentation should still mention\n+  the extra explicitly as long as possible (until it is clear that most/all users\n+  are using package installers that implement this PEP). There is no downside to\n+  keeping the extra be explicitly mentioned, but this will ensure that users with\n+  modern tooling who do not read documentation (which may be a non-negligeable\n+  fraction of the user community) will start getting the recommended\n+  dependencies by default.\n+\n+* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n+  be the default, comes with the same caveats that it does prior to this PEP, which\n+  is that users will only be able to use this extra for releases that define\n+  this extra. This might seem obvious, but consider a package that has a version\n+  1.0 prior to using default extras. Suppose that package now defines\n+  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n+  a minimal version of the package cannot declare the following dependency::\n+\n+    package[minimal]>=1.0\n+\n+  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n+  unknown extras, so it might be possible to do this, but there is no guarantee\n+  that other tools won't error on an unrecognized extra).\n+\n+  The easiest solution to this problem is for package authors to define a no-op\n+  ``minimal`` extra as soon as possible, even if only planning to adopt default\n+  extras further down the road, as it will allow ``package[minimal]`` to work\n+  for versions prior to when defaults were adopted.\n+\n+Avoiding the addition of many default dependencies\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+One temptation for authors might be to include many dependencies by default since\n+they can provide a way to opt out from these. We recommend however that authors\n+carefully consider what is included by default to avoid unecessarily bloating\n+installations and complicating dependency trees. Using default extras does not\n+mean that all extras need to be defaults, and there is still scope for users to\n+explicitly opt in to non-default extras.\n+\n+Inheriting from default extras\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+If package authors choose to make an extra be installed by default, it is important\n+that they are aware that if users explicitly specify another extra, the default may\n+not be installed, unless they use the approach described in `Supporting minimal\n+installations while not always removing default extras`_.\n+\n+There are cases, such as the interchangeable backends, or the ``minimal`` extras,\n+where ignoring the default if an extra is explicitly specified is the right\n+thing to do. However, for other cases, such as using default extras to include\n+recommended dependencies while still providing a way to do minimal installs, it\n+may be that many of the other extras *should* explicitly 'inherit' the default\n+extra(s), so package authors should carefully consider in which cases they want\n+the default extras to be installed.\n+\n+Incompatible extras\n+^^^^^^^^^^^^^^^^^^^\n+\n+In some cases, it may be that packages have extras that are mutually\n+incompatible. In this case, we recommend against using the default extra\n+feature for any extra that contains a dependency that could be incompatible with\n+another.\n+\n+Consider a package that has extras ``package[A]`` and ``package[B]``. Users\n+could already currently try and install ``package[A]`` and ``package[B]`` or\n+``package[A,B]`` which would result in a broken installation, however it would\n+at least be explicit that both extras were being installed. Making ``A`` into a\n+default extra however could lead to unintuitive issues. A user could do:\n+\n+.. code-block:: console\n+\n+    $ pip install package  # this installs package[A]\n+    $ pip install package[B]\n+\n+and end up with a broken installation, even though A and B were never explicitly\n+both installed. For this reason, we recommend against using default extras\n+for dependencies where this is likely to be an issue.\n+\n+Circular dependencies\n+^^^^^^^^^^^^^^^^^^^^^\n+\n+Authors need to take special care when circular dependencies are present. For instance,\n+consider the following dependency tree::\n+\n+    package1\n+    \u2514\u2500\u2500 package2\n+        \u2514\u2500\u2500 package1\n+\n+If ``package1`` has a default extra named ``recommended`` and a ``minimal``\n+extra which is empty, then:\n+\n+.. code-block:: console\n+\n+    $ pip install package1[minimal]\n+\n+will still result in the ``recommended`` extra being installed if ``package2``\n+continues to depend on ``package1`` (with no extras specified). If the dependency\n+tree was updated to instead be::\n+\n+    package1\n+    \u2514\u2500\u2500 package2\n+        \u2514\u2500\u2500 package1[minimal]\n+\n+Then ``package1`` would no longer be installable with tools that do not yet\n+implement this PEP (if those tools would fail on unrecognized extras). Authors\n+therefore need to carefully consider a migration plan, coordinating with the\n+authors of ``package2``.\n+\n+\n+Packaging repository maintainers\n+--------------------------------\n+\n+The impact on individuals who repackage Python libraries for different\n+distributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n+<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\n+so on, needs to be considered. Not all package distributions have mechanisms\n+that would line up with the approach described. In fact, some distributions such\n+as conda, do not even have the concept of extras.\n+\n+There are two cases to consider here:\n+\n+* In cases where the repackaging is done by hand, such as for a number of conda-forge\n+  recipes, and especially where there is no equivalent to extras, the\n+  introduction of default extras should not have a large impact since manual\n+  decisions already have to be made as to which dependencies to include (for\n+  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n+  `Motivation`_ includes all the ``recommended`` dependencies by default since\n+  there is no way for users to explicitly request them otherwise).\n+\n+* In cases where the repackaging is done in an automated, way, distribution maintainers\n+  will need to carefully consider how to treat default extras, and this may\n+  imply a non-negligible amount of work and discussion.\n+\n+It is impossible for a PEP such as this to exhaustively consider each of the\n+different package distributions. However, ultimately, default extras should be\n+understood as how package authors would like their package to be installed for\n+the majority of users, and this should inform decisions about how default extras\n+should be handled, whether manually or automatically.\n \n Reference Implementation\n ========================",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 16,
      "reason type": "Other",
      "reason text": "The diff is purely formatting: converting inline command examples into explicit code-block sections with code-block directives and shell prompts, adjusting indentation to fit the code-block styling. No requirements text, constraints, or meanings were added, removed, or changed.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "-------------------------------------------------\n \n Another option to unselect extras would be to implement this at the\n-level of packaging tools. For instance, pip could include an option such as::\n+level of packaging tools. For instance, pip could include an option such as:\n+\n+.. code-block:: console\n \n-    pip install package --no-default-extras\n+    $ pip install package --no-default-extras\n \n This option could apply to all or specific packages, similar to\n-the ``--no-binary`` option, e.g.,::\n+the ``--no-binary`` option, e.g.,:\n \n-    pip install package --no-default-extras :all:\n+.. code-block:: console\n+\n+    $ pip install package --no-default-extras :all:\n \n The advantage of this approach is that tools supporting default extras could\n also support unselecting them. This approach would be similar to the ``--no-install-recommends``",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 17,
      "reason type": "New",
      "reason text": "Added a new 'Open issues' section with a discussion item 'Should ``package[]`` disable default extras?' (along with supporting rationale) that was not present in the old version. This introduces a fresh discussion item rather than modifying or clarifying existing requirements.",
      "old_version": {
        "version id": 1,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case. The present PEP will describe a solution for this use case.\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which requires either PySide or PyQt to be installed\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898/38>`__\nas well as in numerous issues and pull requests. The solution that will be\npresented below:\n\n* does not break backward-compatibility of existing packaging infrastructure\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_.\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependencies`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependencies`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are not installed. Otherwise, the default extras are used.\n\nFor example, if a package\ndefines an ``extra1`` default extra as well as a non-default ``extra2``\nextra, then if a user were to install the package with::\n\n    pip install package\n\nthe ``extra1`` dependency would be included. If the user instead uses::\n\n    pip install package[extra2]\n\nthen the ``extra1`` extra would not be installed.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras. For instance::\n\n    pip install package package[extra2]\n\nshould install the default extras.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`How to teach this`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nBackward Compatibility\n======================\n\nAll package specification cases valid under :pep:`508` will remain valid.\nTherefore, this proposal is fully backward-compatible with existing :pep:`508`\nusage.\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain fully backward-compatible with older packaging tools - with\nthe only difference that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nThe only conceptual backward-compatibility issue to consider is the fact that\nthis PEP changes extras to no longer be strictly additive, in that specifying\nan extra such as ``minimal`` could result in fewer packages being installed.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThe rule above regarding only installing default extras when no extras\nare explicitly specified, combined with the introduction of the\n``Default-Extra:`` keyword and ``default-optional-dependencies`` metadata key\nallows us to address several different use cases. Below we take a look at the\ntwo specific use cases raised in the `Motivation`_ section and how package\nmaintainers should be taught to address these.\n\nRecommended dependencies and minimal installations\n--------------------------------------------------\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nPackages requiring at least one backend or frontend\n---------------------------------------------------\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nSupporting minimal installations while not always removing default extras\n-------------------------------------------------------------------------\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependencies = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nTeaching package authors\n------------------------\n\nPackages making use of any of the approaches above must ensure that they\nproperly document the options available to users in terms of installation.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as::\n\n    pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,::\n\n    pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0ff88ad4186ed5f3977920b8bcfb34bd65e127de",
        "date": "2025-01-22 17:30:58 +0000"
      },
      "new_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "diff": "maintainers do not actually want to support an installation without any extras,\n for example in cases where at least one backend or frontend must be installed.\n \n+Open issues\n+===========\n+\n+Should ``package[]`` disable default extras?\n+--------------------------------------------\n+\n+Currently, the PEP as written above does not allow ``package[]`` to be\n+equivalent to installing the package with no extras, but there would be some\n+benefits to allowing this:\n+\n+* It would avoid different packages using different names for a 'no default'\n+  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n+  burden for people who don\u2019t want to have to scan through source code or\n+  documentation to figure out whether there is the equivalent of a ``minimal``\n+  extra.\n+\n+* It would allow people who want to use existing packages as-is and future\n+  versions of those packages with no default extras to use ``package[]`` because\n+  that syntax works right now, so it would provide a consistent way over time to\n+  get a minimal install.\n+\n+On the other hand, it is not clear at this point whether any tools are currently\n+relying on ``package[]`` being identical to ``package`` in a way that would\n+break compatibility if this was done, so this needs to be investigated.\n+\n Copyright\n =========",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 18,
      "reason type": "Typo",
      "reason text": "Fixed a duplicate word in the Motivation section: changed 'that that provide' to 'that provide', a minor grammatical correction that does not alter meaning.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "Various use cases for default extras and possible solutions in this PEP were discussed\n extensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\n-These fall into two broad cases that that provide the\n+These fall into two broad cases that provide the\n motivation for the present PEP.\n \n Recommended but not required dependencies",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 19,
      "reason type": "Typo",
      "reason text": "Typographical/grammatical correction: replaced the hyphenated 'typical -users' with 'typical users' and adjusted punctuation, preserving the original meaning.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "extend the functionality or performance of a package. In some cases, it can be\n difficult to determine which dependencies should be required and which should be\n categorized as extras. A balance must be struck between the needs of typical\n-users (who may prefer most features to be available 'by default') and users who\n+users, who may prefer most features to be available by default, and users who\n want minimal installations without large, optional dependencies. One solution\n with existing Python packaging infrastructure is for package maintainers to\n define an extra called, for example, ``recommended``, which",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 20,
      "reason type": "Meaning",
      "reason text": "The primary change is updating the default-extras mapping: sunpy[all] is added to the recommended defaults while tensorflow[and-cuda] is removed, changing which extras are installed by default without altering the overall structure of the requirement.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "include extra dependencies by default include:\n \n * `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n+* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n * `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n-* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n \n Packages supporting multiple backends or frontends\n --------------------------------------------------",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 21,
      "reason type": "Meaning",
      "reason text": "The change replaces the examples of supported backends in the 'Packages supporting multiple backends or frontends' section. Old text listed BLAS/LAPACK and FFT libraries; new text uses backend databases (MySQL, PostgreSQL, SQLite). This shifts the illustrative focus and slightly adjusts wording (e.g., using 'e.g.,' and minor phrasing changes), altering the implied scope of default-backend/backends examples rather than merely clarifying or correcting grammar.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "<https://pypi.org/project/PyQt6/>`_, `PySide2\n   <https://pypi.org/project/PySide2/>`_, or `PySide6\n   <https://pypi.org/project/PySide6/>`_\n-* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n-* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n+* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n+  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n \n With current packaging standards, maintainers have to either\n-require one of the backends or frontends, or require users\n-to always specify extras, e.g. ``package[backend]`` and therefore risk users\n+require one of the backends or frontends or require users\n+to always specify extras, e.g., ``package[backend]``, and therefore risk users\n having an unusable installation if they only install ``package``. Having a\n way to specify one or more default backend or frontend and providing a way to\n override these defaults would provide a much better experience for users, and\n the approach described in this PEP will allow this.\n \n Note that this PEP does not aim to address the issue of disallowing conflicting\n-or incompatible extras - for example if a package requires exactly one frontend\n+or incompatible extras, for example if a package requires exactly one frontend\n or backend package. There is currently no mechanism in Python packaging\n infrastructure to disallow conflicting or incompatible extras to be installed,\n and this PEP does not change that.",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 22,
      "reason type": "Summarization/shortening",
      "reason text": "The change shortens the sentence by removing the word 'vigorously' from 'extensively and vigorously discussed' to 'discussed extensively', thereby summarizing the sentence without changing its meaning.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n \n In all three cases, installing the package without any extras results in a\n-broken installation (and this is a commonly reported issue for some of these\n-packages).\n+broken installation, and this is a commonly reported support issue for some of these\n+packages.\n \n Rationale\n =========\n \n-A number of possible solutions have been extensively and vigorously discussed by\n+A number of possible solutions have been discussed extensively by\n the community for several years, including in `this DPO thread\n <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\n as well as in numerous issues and pull requests. The solution that is",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 23,
      "reason type": "Typo",
      "reason text": "A small punctuation/grammar correction: added commas to the sentence to improve readability without changing meaning ('It is the only solution out of all those discussed that...' -> 'It is the only solution, out of all those discussed, that...').",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n * re-uses the syntax from :pep:`508`\n \n-It is the only solution out of all those discussed that meets all three criteria.\n+It is the only solution, out of all those discussed, that meets all three criteria.\n \n Specification\n =============",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 24,
      "reason type": "Typo",
      "reason text": "Minor grammar adjustment: changed 'without any extras specified explicitly' to 'without any extras being specified explicitly' to improve readability without changing meaning.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "A new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\n metadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\n For this field, each entry must be a string specifying an extra that will be\n-automatically included when the package is installed without any extras specified explicitly.\n+automatically included when the package is installed without any extras being specified explicitly.\n \n Only entries already specified in a `Provides-Extra\n <https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 25,
      "reason type": "Other",
      "reason text": "No requirement-level change detected between old and new versions. The diff snippet appears to inject an analysis/template block and does not modify any substantive requirement text.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "\"backend3\"\n     ]\n \n-\n Overriding default extras\n -------------------------",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 26,
      "reason type": "Meaning",
      "reason text": "The meaning/behavior of the empty extras syntax (package[]) was changed: from the old version's note that package[] remains equivalent to package and should not be provided as a way to install without default extras, to the new version's explicit interpretation that package[] means install without default extras unless the package appears elsewhere in the dependency tree, in which case the default extras would be installed. This changes the default-extras behavior.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "then the default extra should be installed because ``package`` appears at least\n once with no extras specified.\n \n-Note that ``package[]`` would continue to be equivalent to ``package`` and would\n-not be provided as a way to install without default extras (see the `Rejected\n-Ideas`_ section for the rationale).\n+An empty set of extras, such as ``package[]`` should be interpreted as meaning\n+that the package should be installed *without* any default extras (unless\n+``package`` appears elsewhere in the dependency tree, in which case, the default\n+extra *would* be installed as mentioned above). This\n+would provide a universal way of obtaining a minimal installation of a package.\n \n We also note that some tools such as `pip`_ currently ignore unrecognized\n extras, and emit a warning to the user to indicate that the extra has not been",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 27,
      "reason type": "Generalization",
      "reason text": "The old version touched some too specific issues, while the new version generalizes it.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "...\n \n For tools that behave like this (rather than raising an error), if an extra is\n-recognized as invalid in a dependency specification, it should be ignored and\n-treated as if the user has not passed an explicit extra. If none of the provided\n-extras are valid, default extras should be installed.\n-\n-Installing without default extras\n-\n-In some cases, package maintainers may want to facilitate installing packages\n-without any default extras. In this case, as will be shown in more detail in\n-`Examples`_, the best approach is to define an extra which could be\n-called e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\n-maintainer) which would be an empty set of dependencies. If this extra is\n-specified, no default extras will be included, so that e.g. ``package[minimal]``\n-would include only required dependencies and no extras. Note that this requires\n-no additional specification and is a natural consequence of the rule described\n-in `Overriding default extras`_.\n-\n-There are however valid use cases where package maintainers may not want to\n-provide this. For example, in the case of the multiple possible frontends or\n-backends, it may be that the package would not be functional without any of the\n-options. To take a specific example, a package may need either PyQt or PySide to\n-be installed but will not work if none are provided, so a package maintainer may\n-therefore not want to provide an option to install the package without any\n-extras.\n+recognized as invalid in a dependency specification, it should be ignored, and\n+if all specified extras are invalid, then this should be considered equivalent\n+to ``package[]`` (rather than ``package``) and *not* install any default extras.\n+\n+Finally, we note (as also discussed in `Relying on tooling to deselect\n+any default extras`_) that package installers are allowed to implement their\n+own options to control the above behavior, for example implementing an option\n+that disables default extras for some or all packages regardless of where these\n+packages appear in the dependency tree. If such tool-specific options are\n+implemented, tool developers should make these opt-in,\n+and users should experience the above PEP 771 behavior as default.\n \n Examples\n --------",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 28,
      "reason type": "Other",
      "reason text": "Editorial formatting and minor content tweaks: the diff mainly reflows text (line wrapping) in the Motivation section and updates a couple of example bullets (changing tensorflow to sunpy and the extras mapping). The core requirements, their intent, and structure remain unchanged, so this is not a semantic change.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "Recommended dependencies and minimal installations\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-First, we consider the case of packages that want recommended\n-but not strictly required dependencies installed by default, while also\n-providing a way to only install the required dependencies.\n+First, we consider the case of packages that want recommended but not strictly\n+required dependencies installed by default, while also providing a way to only\n+install the required dependencies.\n \n In order to do this, a package maintainer would define an extra called\n ``recommended`` containing the recommended but not required dependencies, and",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 29,
      "reason type": "Summarization/shortening",
      "reason text": "The old version was lengthy, with extensive examples and rationale about default extras and minimal installations. The new version condenses this content, removing redundancy while preserving the core meaning, i.e., a summarization/shortening change.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "\"package2\"\n     ]\n \n-In this specific case, a package maintainer may want to allow users to also\n-install the package without the recommended dependencies, in which case they\n-could define an empty extra:\n-\n-.. code-block:: toml\n-\n-    [project.optional-dependencies]\n-    minimal = []\n-    recommended = [\n-        \"package1\",\n-        \"package2\"\n-    ]\n-\n-This would then allow users to install ``package[minimal]`` which, since\n-there would be an extra explicitly specified, would mean the default extra\n-does not get installed, and since the ``minimal`` extra is empty, no\n-additional dependencies would be installed.\n-\n-Maintainers would have the choice as to whether to offer the capability to do a\n-minimal installation or not - in some cases, such as highlighted in the next\n-section, this might not be desirable.\n+If this package was called ``package``, users installing ``package`` would\n+then get the equivalent of ``package[recommended]``. Users could alternatively\n+install ``package[]`` which would install the package without the default extras.\n \n To take a one of the concrete examples of package from the `Motivation`_\n section, the `astropy`_ package defines a ``recommended`` extra that users are\n currently instructed to install in the default installation instructions.\n With this PEP, the ``recommended`` extra could be declared as being a default\n-extra, and a new ``minimal`` extra could be provided for users wishing to\n-retain the ability to install only the strictly required dependencies:\n+extra:\n \n .. code-block:: toml",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 30,
      "reason type": "Other",
      "reason text": "The primary change is the deletion of the 'minimal' extra under [project.optional-dependencies] (minimal = []). This removes a previously defined optional-dependency path, changing the documented behavior and semantics of default extras. It is not a typo, new requirement, or clarification, but a removal that alters the requirement set.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "]\n \n     [project.optional-dependencies]\n-    minimal = []\n     recommended = [\n         \"scipy\",\n         \"...\"",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 31,
      "reason type": "Clarification",
      "reason text": "Wording change without influencing the meaning.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "$ pip install astropy\n \n-would then also install optional but important optional dependencies such as `scipy\n-<https://www.scipy.org>`_. Advanced users who want a minimal\n-install could then use:\n+would then install optional but recommended dependencies such as\n+`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\n+could then use:\n \n .. code-block:: console\n \n-    $ pip install astropy[minimal]\n-\n+    $ pip install astropy[]\n \n Packages requiring at least one backend or frontend\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 32,
      "reason type": "Deletion",
      "reason text": "Removed a sentence in the 'Syntax for deselecting extras' section stating that maintainers would not necessarily provide a way to install without any extras; this deletes a constraint within an existing requirement block.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "\"package3\"\n     ]\n \n-Unlike the previous example however, maintainers would not necessarily provide a\n-way to do an installation without any extras since it might leave the package in\n-an unusable state.\n-\n If packages can support e.g. multiple backends at the same time, and some of\n the backends should always be installed, then the dependencies for these must be given\n as required dependencies rather than using the default extras mechanism.",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 33,
      "reason type": "Meaning",
      "reason text": "The change rewords and renames the existing guidance about not removing default extras, updating terminology and examples rather than introducing a new requirement. Specifically, the subsection header changes from 'Supporting minimal installations while not always removing default extras' to 'Supporting extras that should not remove default extras', and the examples shift from using package[minimal] to package[] (no extras) and from package[additional] to package[alternative] (a non-default alternative), while still describing opt-in extras that do not remove defaults.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "$ pip install napari[pyside6]\n \n-Supporting minimal installations while not always removing default extras\n-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+Supporting extras that should not remove default extras\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-An additional case we consider here is where a package maintainer wants to support\n-minimal installations without any extras, but also wants to support having users\n-specify additional extras without removing the default one. Essentially, they\n-would want:\n+An additional case we consider here is where a package maintainer wants to\n+support the ability for users to opt-in to non-default extras, without removing\n+default extras. Essentially, they might want:\n \n-* ``package[minimal]`` to give an installation without any extras\n-* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n-* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n+* ``package[]`` to give an installation without any extras\n+* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n+* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n+* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n \n This could be achieved with e.g:",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 34,
      "reason type": "Other",
      "reason text": "The changes modify the structure and content of the [project.optional-dependencies] block: the 'minimal' key is removed, a new 'alternative' key is added with 'package3', and 'package3' is moved out of 'additional' into 'alternative' while 'package4' is added to 'additional'. This represents a semantic/behavioral change in the default-extras configuration rather than a simple typo, new standalone requirement, or minor wording adjustment; it alters which extras are installed by default and how defaults interact, so it does not map cleanly to the predefined categories (hence 'Other').",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "]\n \n     [project.optional-dependencies]\n-    minimal = []\n     recommended = [\n         \"package1\",\n         \"package2\"\n     ]\n+    alternative = [\n+        \"package3\"\n+    ]\n     additional = [\n         \"package[recommended]\",\n-        \"package3\"\n+        \"package4\"\n     ]\n \n The ability for a package to reference itself in the extras is supported by",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 35,
      "reason type": "Other",
      "reason text": "The primary change is the deletion of the line 'minimal = []' from [project.optional-dependencies] in the New Version. This is an editorial/shortening adjustment (removing a demonstration of a default-empty extra) rather than a substantive change to requirements, nor a new or meaning-change change.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "]\n \n     [project.optional-dependencies]\n-    minimal = []\n     recommended = [\n         \"scipy\",\n         \"...\"",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 36,
      "reason type": "New",
      "reason text": "A new section 'Packages with multiple kinds of defaults' was added to the New Version, introducing the concept of multiple default backends/frontends (default backend and default frontend) with example usage and rationale, which was not present in the Old Version.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "$ pip install astropy[recommended, jupyter]\n \n+Packages with multiple kinds of defaults\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+In some cases, it may be that packages need multiple kinds of defaults. As an example,\n+in `Packages requiring at least one backend or frontend`_, we considered the case of packages\n+that have *either* backends or frontends, but in some cases, packages may have to support\n+backends *and* frontends, and want to specify one or more default frontend and one or\n+more default backend.\n+\n+Ideally, one may want the following behavior:\n+\n+.. code-block:: console\n+\n+    $ pip install package  # installs default backend and frontend\n+    $ pip install package[]  # installs no backends or frontends\n+    $ pip install package[backend1]  # installs backend1 and default frontend\n+    $ pip install package[frontend2]  # installs frontend2 and default backend\n+    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n+\n+However, this PEP chooses not to provide a mechanism for making it so that e.g., if\n+``backend1`` is specified, the default backend would be disabled, but the\n+default frontend would be enabled, since this adds complexity.\n+\n+Maintainers should instead for now document that if a backend or frontend is\n+explicitly specified, both backend and frontend need to be specified.\n+Discoverability for users who want to do this should not be an issue however since users\n+need to read the documentation in any case to find out what backends or frontends are\n+available, so they can be shown at the same time how to properly use the extras for\n+backends and frontends.\n+\n+One option to increase user friendliness is that maintainers can create extras\n+called for example ``defaultbackend`` and ``defaultfrontend`` which do install\n+the default backend and frontend. They can then recommend that users do:\n+\n+.. code-block:: console\n+\n+    $ pip install package  # installs default backend and frontend\n+    $ pip install package[]  # installs no backends or frontends\n+    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n+    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n+    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n+\n+This would allow (if desired) users to then get whatever the recommended backend\n+is, even if that default changes in time.\n+\n+If there is a desire to implement a better solution in future, we believe this\n+PEP should not preclude this. For example, one could imagine in future adding\n+the ability for an extra to specify *which* default extras it disables, and if\n+this is not specified then explicitly specified extras would disable all default\n+extras (consistent with the present PEP).\n \n Backward Compatibility\n ======================",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 37,
      "reason type": "Summarization/shortening",
      "reason text": "The change shortens the explanatory narrative by removing the detailed discussion about the 'minimal' extra and its dependencies, replacing the longer example with a briefer one that still conveys the default/extras behavior. No new behavior is introduced; the intent remains the same, so this is a Summarization/shortening change.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "fewer dependencies being installed.\n \n A specific example of change in behavior can be seen with `pip`_: consider a\n-package ``package`` which has a required dependency of ``numpy``, a (default)\n-extra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\n-which does not contain any dependencies. If a user installs ``package[minimal]``,\n-only ``package`` and ``numpy`` will be installed. If a user then does:\n+package ``package`` which has a required dependency of ``numpy``, and a default\n+extra called ``recommended`` which includes ``scipy``. If a user installs\n+``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\n+does:\n \n .. code-block:: console",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 38,
      "reason type": "New",
      "reason text": "Inserted a new informational paragraph introducing PEP 751 (a new file format to replace tools like pip freeze), adding that the format will install packages without resolving dependencies and be compatible with default extras; this is new content not present in the old version.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "may be changes in behavior in packaging tools due to the change in the\n assumption about what impact an extra can have.\n \n+It is worth noting that the recently-accepted :pep:`751` defines a new file\n+format which is intended to replace alternatives such as the ``pip freeze``\n+output and other tools in future. The new file format is designed so that the\n+packages in the file are installed *without* resolving dependencies, which means\n+that it will be fully compatible with default extras as specified in this PEP,\n+and will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n+\n Security Implications\n =====================",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 39,
      "reason type": "Meaning",
      "reason text": "The diff primarily changes the semantics of the package[] syntax: it now defines package[] as a backward-compatible universal minimal-install option that yields a minimal installation even with older packaging tools, i.e., a change in intent/behavior (Meaning). The other edits are minor typographical corrections and non-substantive clarifications.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "the extra explicitly as long as possible (until it is clear that most/all users\n   are using package installers that implement this PEP). There is no downside to\n   keeping the extra be explicitly mentioned, but this will ensure that users with\n-  modern tooling who do not read documentation (which may be a non-negligeable\n+  modern tooling who do not read documentation (which may be a non-negligible\n   fraction of the user community) will start getting the recommended\n   dependencies by default.\n \n-* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n-  be the default, comes with the same caveats that it does prior to this PEP, which\n-  is that users will only be able to use this extra for releases that define\n-  this extra. This might seem obvious, but consider a package that has a version\n-  1.0 prior to using default extras. Suppose that package now defines\n-  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n-  a minimal version of the package cannot declare the following dependency::\n-\n-    package[minimal]>=1.0\n-\n-  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n-  unknown extras, so it might be possible to do this, but there is no guarantee\n-  that other tools won't error on an unrecognized extra).\n-\n-  The easiest solution to this problem is for package authors to define a no-op\n-  ``minimal`` extra as soon as possible, even if only planning to adopt default\n-  extras further down the road, as it will allow ``package[minimal]`` to work\n-  for versions prior to when defaults were adopted.\n+* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n+  authors will be able to document ``package[]`` as a backward-compatible\n+  universal way of getting a minimal installation. For packages that define\n+  default extras, installing ``package[]`` will always give a minimal\n+  installation even with older versions of packaging tools such as `pip`_, and\n+  releases of this package that pre-date the introduction of default extras for\n+  a specific package will also be installable with ``package[]`` (although in\n+  these cases this will be equivalent to ``package``). For packages that do not\n+  define default extras, ``package[]`` will continue to be equivalent to\n+  ``package``.\n \n Avoiding the addition of many default dependencies\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n One temptation for authors might be to include many dependencies by default since\n they can provide a way to opt out from these. We recommend however that authors\n-carefully consider what is included by default to avoid unecessarily bloating\n+carefully consider what is included by default to avoid unnecessarily bloating\n installations and complicating dependency trees. Using default extras does not\n mean that all extras need to be defaults, and there is still scope for users to\n explicitly opt in to non-default extras.\n \n+Default extras should generally be treated with the same \"weight\" as required\n+dependencies. When a package is widely used, introducing a default extra will\n+result in that extra's dependencies being transitively included -- unless all\n+downstream packages are updated to explicitly opt out using minimal installation\n+specifications.\n+\n+As an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n+\n Inheriting from default extras\n ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n If package authors choose to make an extra be installed by default, it is important\n that they are aware that if users explicitly specify another extra, the default may\n-not be installed, unless they use the approach described in `Supporting minimal\n-installations while not always removing default extras`_.\n+not be installed, unless they use the approach described in `Supporting extras\n+that should not remove default extras`_.\n \n-There are cases, such as the interchangeable backends, or the ``minimal`` extras,\n+There are cases, such as the interchangeable backends,\n where ignoring the default if an extra is explicitly specified is the right\n thing to do. However, for other cases, such as using default extras to include\n recommended dependencies while still providing a way to do minimal installs, it",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 40,
      "reason type": "Clarification",
      "reason text": "The New Version adds a dedicated section 'Documenting packages with default extras' that clarifies how authors should document the behavior of default extras, including equivalence of package and package[] in certain contexts and how default extras interact with other extras. This is a clarifying expansion of documentation guidance rather than a change in the core requirements or behavior; it rephrases and adds guidance to help users understand and developers adopt it.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "\u2514\u2500\u2500 package2\n         \u2514\u2500\u2500 package1\n \n-If ``package1`` has a default extra named ``recommended`` and a ``minimal``\n-extra which is empty, then:\n+If ``package1`` has a default extra named ``recommended`` then:\n \n .. code-block:: console\n \n-    $ pip install package1[minimal]\n+    $ pip install package1[]\n \n will still result in the ``recommended`` extra being installed if ``package2``\n-continues to depend on ``package1`` (with no extras specified). If the dependency\n-tree was updated to instead be::\n+continues to depend on ``package1`` (with no extras specified). This could be\n+solved by changing the dependency tree to instead be::\n \n     package1\n     \u2514\u2500\u2500 package2\n-        \u2514\u2500\u2500 package1[minimal]\n+        \u2514\u2500\u2500 package1[]\n \n-Then ``package1`` would no longer be installable with tools that do not yet\n-implement this PEP (if those tools would fail on unrecognized extras). Authors\n-therefore need to carefully consider a migration plan, coordinating with the\n-authors of ``package2``.\n+assuming that indeed ``package2`` does not depend on any features provided by\n+the extra dependencies of ``package1``. Authors therefore need to carefully\n+consider a migration plan, coordinating with the authors of ``package2``.\n \n+Documenting packages with default extras\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+Regardless of how default extras are used, package authors should aim to ensure\n+that their package's documentation makes it clear how extras are to be\n+used. 'Best practices' documentation should mention:\n+\n+* that installing ``package`` will be equivalent to ``package[<default extras>]``\n+* that installing ``package[]`` will include only minimal/required dependencies,\n+  but that this will not guarantee that optional dependencies do not get installed\n+  if ``package`` appears anywhere else in the dependency tree\n+* what other optional extras are available, and whether or not they disable the\n+  default extras (since this can be controlled as described in `Supporting\n+  extras that should not remove default extras`_)\n+* any instructions specific to packages that might have e.g. default backends\n+  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n \n Packaging repository maintainers\n --------------------------------",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 41,
      "reason type": "Other",
      "reason text": "Editorial addition: the diff section was introduced in the new version, stating that a modified version of the Flit package is used. This does not change the requirements or intent of the PEP; content remains equivalent aside from the patch note.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "contains a modified version of the `Flit\n <https://flit.pypa.io/en/stable/>`_ package.\n \n-\n-\n The implementations above are proofs-of-concept at this time and the existing changes have\n not yet been reviewed by the relevant maintainers. Nevertheless, they are\n functional enough to allow for interested maintainers to try these out.",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 42,
      "reason type": "New",
      "reason text": "Added a substantial set of new rejected-ideas options under the Rejected Ideas section, introducing several alternative designs and considerations (Using a meta-package for recommended installations; Mismatch between package and module name; Multiple repositories or monorepos; Depending on the minimal package; Uninstallation; Package distributions; Synchronizing metadata; Summary). These items did not exist in the Old Version and expand the discussion without altering existing requirements.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "Rejected Ideas\n ==============\n \n+Using a meta-package for recommended installations\n+--------------------------------------------------\n+\n+Using existing packaging tools and infrastructure, package maintainers who want\n+to provide a minimal installation for some users and a default non-minimal\n+installation for regular users (e.g. with recommended dependencies or a default\n+backend) can technically already achieve this if they are willing to distribute\n+two packages instead of one -- for example ``package-core`` which would be the main package\n+with minimal dependencies, and ``package`` which would be a metapackage that\n+would depend on ``package-core`` with optional dependencies enabled.\n+\n+Taking once again a concrete example from the `Motivation`_\n+section, the `astropy`_ package defines a ``recommended`` extra that users are\n+currently instructed to install in the default installation instructions.\n+In principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\n+and then create a new ``astropy`` package which would be a metapackage that would\n+contain the following dependencies section:\n+\n+.. code-block:: toml\n+\n+    dependencies = [\n+        \"astropy-core[recommended]\"\n+    ]\n+\n+Since users may want to pin or place version constraints on the ``astropy``\n+meta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\n+the same versions as the core package, and would need to use strict pinning\n+in the dependency section, e.g.:\n+\n+.. code-block:: toml\n+\n+    version = \"7.1.0\"\n+    dependencies = [\n+        \"astropy-core[recommended]==7.1.0\"\n+    ]\n+\n+This idea may seem appealing because it is technically already feasible. However, in\n+practice, many projects have opted not to do this, for a number of reasons, which\n+we now take a look at. Some of these may not be applicable to future new projects,\n+but some of them apply to all projects, old and new.\n+\n+Mismatch between package and module name\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+In terms of naming, there are two main options for a package that wants to use the metapackage\n+approach:\n+\n+* The first option is for the existing package to be kept as-is, which means\n+  that ``package`` would provide the minimal installation, and to then create a\n+  new metapackage with a different name, such as ``package-all``. However, this\n+  suffers from one of the problems that motivated this PEP in the first place -\n+  users are often not aware that they can do e.g. ``package[recommended]``, so\n+  in the same way, they might not realise that ``package-all`` exists. This once\n+  again places the burden on the average user to discover this, rather then\n+  shifting some of the burden to more advanced users.\n+\n+* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n+  for the new meta-package to be called ``package``. This is a better option\n+  than the first one, but is not ideal, as it then introduces a non-intuitive\n+  mismatch between the package name and module name, in that ``package-core`` provides\n+  the ``package`` module, and ``package`` does not provide any module. An example of why\n+  this would lead to confusion is that an average user might think that uninstalling\n+  the ``package`` module would be done with e.g.:\n+\n+  .. code-block:: shell\n+\n+      $ pip uninstall package\n+\n+  but this would not be the case (the ``package`` module would still work), and\n+  it may not be obvious to this user that the ``package-core`` package even\n+  exists.\n+\n+Multiple repositories or monorepos\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+This approach requires either maintaining two repositories instead of one, or\n+switching to using a monorepo which would contain both packages. Neither option\n+is ideal:\n+\n+* Splitting into two repositories places a long-term additional burden on\n+  maintainers, who have to make sure that these stay in sync (in terms of\n+  version but also other aspects such as extras, as will be discussed in\n+  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n+  `Mismatch between package and module name`_ has additional complications here\n+  \u2013\u00a0either the names of the repositories match the packages, in which case any\n+  user who has a checkout of the previous ``package`` repository will need to\n+  update their remote URLs or any git clone URLs to point to the\n+  ``package-core`` repository. The alternative is to preserve the ``package``\n+  repository to contain the ``package-core`` package, and have a different name\n+  for the meta-package, but this could lead to confusion.\n+\n+* Switching to a monorepo may be a significant change for some projects,\n+  and it is not uncommon for tools to assume by default that a single repository\n+  corresponds to a single package - while these can often be configured to then\n+  work with a monorepo, it is an additional burden on the maintainers. In\n+  addition, if the main package is moved to a sub-directory in the monorepo, any\n+  user that is e.g. pip installing the package from the repository URL will need\n+  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n+  the repo URL), and any existing workflows that clone the repository and assume\n+  the previous layout would break.\n+\n+Depending on the minimal package\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+Packages that need to depend on package versions that are older than the first\n+version where the split was done will not easily be able to depend on the\n+minimal package. Whereas with the main proposal in this PEP, downstream users\n+will be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\n+the introduction of default extras, with the splitting approach it will not be\n+possible for downstream users to depend on e.g. ``package-core>version``, since\n+``package-core`` did not previously exist.\n+\n+A possible solution to this is for developers to release no-op metadata packages\n+for all old versions of a package, but this is a significant additional burden\n+on the maintainers.\n+\n+Uninstallation\n+^^^^^^^^^^^^^^\n+\n+As alluded to when referring to naming issues in `Mismatch between package and\n+module name`_, uninstalling packages will no longer work the way users expect. A\n+user doing:\n+\n+.. code-block:: shell\n+\n+    $ pip uninstall package\n+\n+will still be left with ``package-core``, but may not realise it. This is\n+not just confusing, but is in effect a breaking change that may impact a number\n+of existing workflows.\n+\n+Package distributions\n+^^^^^^^^^^^^^^^^^^^^^\n+\n+Having two packages instead of one would increase the long-term maintenance cost\n+of package distributions simply by virtue of the fact that two packages would\n+have to be released instead of one, and in some cases this would introduce extra\n+manual work at each release.\n+\n+Synchronizing metadata\n+^^^^^^^^^^^^^^^^^^^^^^\n+\n+The main metadata that would be important to keep synchronized between the main\n+package and the metapackage is the version. Anytime a new release of the core\n+package is done, the metapackage would need to have its version updated as well\n+as the version pinning for the core package in the dependencies.\n+\n+In addition, all extras defined in the core package would need to be redefined\n+and kept in sync in the metapackage. For example, if ``package`` defines a\n+``additional`` extra, users should still be able to install\n+``package[additional]``, but users installing the ``package-core`` package should\n+also have the option of doing ``package-core[additional]``.\n+\n+Other metadata that would need to be kept in sync includes for example author\n+information and project URLs.\n+\n+Summary\n+^^^^^^^\n+\n+Overall, this solution would imply a significantly higher maintenance burden,\n+not just in terms of initial set-up and transition (which could already be\n+prohibitive for large established projects), but also in terms of long-term\n+maintenance. This also has the potential for breaking user workflows (in\n+particular around the issue of repositories, and e.g. uninstallation). For all\n+these reasons, we do not consider it a compelling alternative to the present PEP.\n+\n Syntax for deselecting extras\n -----------------------------",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 43,
      "reason type": "Other",
      "reason text": "Editorial deletion of an explanatory sentence in the 'Using a meta-package...' section. The removed sentence was a clarification about compatibility; its deletion does not introduce a new requirement or change the intended behavior, only trimming text. Therefore it's not a new or meaning-changing requirement; it's an editorial content removal.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "extras_require={'': ['package_a']},\n     )\n \n-\n which is valid and equivalent to having ``package_a`` being defined in\n ``install_requires``, so changing the meaning of the empty string would\n break compatibility.",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 44,
      "reason type": "Meaning",
      "reason text": "The revision changes the interpretation of how default extras can be deselected. The old text contained a dedicated 'package[] disables default extras' section and open issues, effectively restricting behavior; the new text replaces it with a permissive note that tooling could expose a flag to disable default extras and clarifies that using such a flag need not guarantee a functional environment. In short, the change alters the meaning/intent of the requirement rather than adding a purely new or corrective detail.",
      "old_version": {
        "version id": 2,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers (who may prefer most features to be available 'by default') and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n* `tensorflow <https://www.tensorflow.org>`_: ``tensorflow[and-cuda]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* BLAS/LAPACK, which have different possible implementations (e.g. OpenBLAS, and MKL)\n* FFT libraries, which also have different implementations (e.g. ``scipy.fft`` and pyFFTW)\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends, or require users\nto always specify extras, e.g. ``package[backend]`` and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras - for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation (and this is a commonly reported issue for some of these\npackages).\n\nRationale\n=========\n\nA number of possible solutions have been extensively and vigorously discussed by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution out of all those discussed that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nNote that ``package[]`` would continue to be equivalent to ``package`` and would\nnot be provided as a way to install without default extras (see the `Rejected\nIdeas`_ section for the rationale).\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored and\ntreated as if the user has not passed an explicit extra. If none of the provided\nextras are valid, default extras should be installed.\n\nInstalling without default extras\n---------------------------------\n\nIn some cases, package maintainers may want to facilitate installing packages\nwithout any default extras. In this case, as will be shown in more detail in\n`Examples`_, the best approach is to define an extra which could be\ncalled e.g. ``minimal`` or ``nodefault`` (the naming would be up to the package\nmaintainer) which would be an empty set of dependencies. If this extra is\nspecified, no default extras will be included, so that e.g. ``package[minimal]``\nwould include only required dependencies and no extras. Note that this requires\nno additional specification and is a natural consequence of the rule described\nin `Overriding default extras`_.\n\nThere are however valid use cases where package maintainers may not want to\nprovide this. For example, in the case of the multiple possible frontends or\nbackends, it may be that the package would not be functional without any of the\noptions. To take a specific example, a package may need either PyQt or PySide to\nbe installed but will not work if none are provided, so a package maintainer may\ntherefore not want to provide an option to install the package without any\nextras.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended\nbut not strictly required dependencies installed by default, while also\nproviding a way to only install the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIn this specific case, a package maintainer may want to allow users to also\ninstall the package without the recommended dependencies, in which case they\ncould define an empty extra:\n\n.. code-block:: toml\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nThis would then allow users to install ``package[minimal]`` which, since\nthere would be an extra explicitly specified, would mean the default extra\ndoes not get installed, and since the ``minimal`` extra is empty, no\nadditional dependencies would be installed.\n\nMaintainers would have the choice as to whether to offer the capability to do a\nminimal installation or not - in some cases, such as highlighted in the next\nsection, this might not be desirable.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra, and a new ``minimal`` extra could be provided for users wishing to\nretain the ability to install only the strictly required dependencies:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then also install optional but important optional dependencies such as `scipy\n<https://www.scipy.org>`_. Advanced users who want a minimal\ninstall could then use:\n\n.. code-block:: console\n\n    $ pip install astropy[minimal]\n\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nUnlike the previous example however, maintainers would not necessarily provide a\nway to do an installation without any extras since it might leave the package in\nan unusable state.\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting minimal installations while not always removing default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to support\nminimal installations without any extras, but also wants to support having users\nspecify additional extras without removing the default one. Essentially, they\nwould want:\n\n* ``package[minimal]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extras)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extras)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package3\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    minimal = []\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, a (default)\nextra called ``recommended`` which includes ``scipy``, and a ``minimal`` extra\nwhich does not contain any dependencies. If a user installs ``package[minimal]``,\nonly ``package`` and ``numpy`` will be installed. If a user then does:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligeable\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Adding a new extra, whether it be ``minimal`` or another new extra that is to\n  be the default, comes with the same caveats that it does prior to this PEP, which\n  is that users will only be able to use this extra for releases that define\n  this extra. This might seem obvious, but consider a package that has a version\n  1.0 prior to using default extras. Suppose that package now defines\n  ``minimal`` in 2.0, then downstream users and packages that want to depend on\n  a minimal version of the package cannot declare the following dependency::\n\n    package[minimal]>=1.0\n\n  because ``package[minimal]==1.0`` does not exist (in practice, pip ignores\n  unknown extras, so it might be possible to do this, but there is no guarantee\n  that other tools won't error on an unrecognized extra).\n\n  The easiest solution to this problem is for package authors to define a no-op\n  ``minimal`` extra as soon as possible, even if only planning to adopt default\n  extras further down the road, as it will allow ``package[minimal]`` to work\n  for versions prior to when defaults were adopted.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting minimal\ninstallations while not always removing default extras`_.\n\nThere are cases, such as the interchangeable backends, or the ``minimal`` extras,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` and a ``minimal``\nextra which is empty, then:\n\n.. code-block:: console\n\n    $ pip install package1[minimal]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). If the dependency\ntree was updated to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[minimal]\n\nThen ``package1`` would no longer be installable with tools that do not yet\nimplement this PEP (if those tools would fail on unrecognized extras). Authors\ntherefore need to carefully consider a migration plan, coordinating with the\nauthors of ``package2``.\n\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\n\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point. Nevertheless, this PEP does not disallow\nthis approach and it is up to the maintainers of different packaging tools to\ndecide if they want to support this kind of option.\n\n``package[]`` disables default extras\n-------------------------------------\n\nAnother way to specify not to install any extras, including default extras, would\nbe to use ``package[]``. However, this would break the current assumption in packaging tools that\n``package[]`` is equivalent to ``package``, and may also result\nin developers overusing ``[]`` by default even when it is not needed. As\nhighlighted in `How to teach this`_, there may also be cases where package\nmaintainers do not actually want to support an installation without any extras,\nfor example in cases where at least one backend or frontend must be installed.\n\nOpen issues\n===========\n\nShould ``package[]`` disable default extras?\n--------------------------------------------\n\nCurrently, the PEP as written above does not allow ``package[]`` to be\nequivalent to installing the package with no extras, but there would be some\nbenefits to allowing this:\n\n* It would avoid different packages using different names for a 'no default'\n  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n  burden for people who don\u2019t want to have to scan through source code or\n  documentation to figure out whether there is the equivalent of a ``minimal``\n  extra.\n\n* It would allow people who want to use existing packages as-is and future\n  versions of those packages with no default extras to use ``package[]`` because\n  that syntax works right now, so it would provide a consistent way over time to\n  get a minimal install.\n\nOn the other hand, it is not clear at this point whether any tools are currently\nrelying on ``package[]`` being identical to ``package`` in a way that would\nbreak compatibility if this was done, so this needs to be investigated.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "0899c62f3714ea56a2233f1af58bf1cacbb714e6",
        "date": "2025-02-06 17:02:06 +0000"
      },
      "new_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "diff": "also support unselecting them. This approach would be similar to the ``--no-install-recommends``\n option for the ``apt`` tool.\n \n-However, this solution is not ideal because it would not allow packages to\n+However, this solution is not ideal on its own because it would not allow packages to\n specify themselves that they do not need some of the default extras of a\n dependency. It would also carry risks for users who might disable all default\n extras in a big dependency tree, potentially breaking packages in the tree that\n-rely on default extras at any point. Nevertheless, this PEP does not disallow\n-this approach and it is up to the maintainers of different packaging tools to\n-decide if they want to support this kind of option.\n-\n-``package[]`` disables default extras\n-\n-Another way to specify not to install any extras, including default extras, would\n-be to use ``package[]``. However, this would break the current assumption in packaging tools that\n-``package[]`` is equivalent to ``package``, and may also result\n-in developers overusing ``[]`` by default even when it is not needed. As\n-highlighted in `How to teach this`_, there may also be cases where package\n-maintainers do not actually want to support an installation without any extras,\n-for example in cases where at least one backend or frontend must be installed.\n-\n-Open issues\n-===========\n-\n-Should ``package[]`` disable default extras?\n-\n-Currently, the PEP as written above does not allow ``package[]`` to be\n-equivalent to installing the package with no extras, but there would be some\n-benefits to allowing this:\n-\n-* It would avoid different packages using different names for a 'no default'\n-  extras (e.g. ``minimal``, ``no-default``, ``no-defaults``) and reduce the\n-  burden for people who don\u2019t want to have to scan through source code or\n-  documentation to figure out whether there is the equivalent of a ``minimal``\n-  extra.\n-\n-* It would allow people who want to use existing packages as-is and future\n-  versions of those packages with no default extras to use ``package[]`` because\n-  that syntax works right now, so it would provide a consistent way over time to\n-  get a minimal install.\n-\n-On the other hand, it is not clear at this point whether any tools are currently\n-relying on ``package[]`` being identical to ``package`` in a way that would\n-break compatibility if this was done, so this needs to be investigated.\n+rely on default extras at any point.\n+\n+Nevertheless, this PEP does not disallow this approach and it is up to the\n+maintainers of different packaging tools to decide if they want to support this\n+kind of option. It is a flag that could at the very least be useful for package\n+maintainers who want to identify places in dependency trees where default extras\n+are being relied on. However, if it is supported, it should be made clear that\n+using this flag does not guarantee a functional environment.\n \n Copyright\n =========",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 45,
      "reason type": "Other",
      "reason text": "The changes are metadata/editorial: only the Discussion-To link was updated and a new entry added to the Post-History. No changes to actual requirements, their meaning, or scope.",
      "old_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "new_version": {
        "version id": 4,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/94905/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n  `09-Jun-2025 <https://discuss.python.org/t/94905/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "816c0571f4050faf47c6a88cdcd9da7a4e94bc6f",
        "date": "2025-06-09 12:29:19 +0100"
      },
      "diff": "Title: Default Extras for Python Software Packages\n Author: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\n Sponsor: Pradyun Gedam <pradyunsg@gmail.com>\n-Discussions-To: https://discuss.python.org/t/79706/\n+Discussions-To: https://discuss.python.org/t/94905/\n Status: Draft\n Type: Standards Track\n Topic: Packaging",
      "old_content_snippet": "",
      "new_content_snippet": ""
    },
    {
      "diff_id": 46,
      "reason type": "Other",
      "reason text": "Metadata change: added a new post-history entry for 09-Jun-2025 in the New Version. No changes to the requirements themselves.",
      "old_version": {
        "version id": 3,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/79706/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "4c4150171c322f2e9e61369d4ad1332dc7eba926",
        "date": "2025-06-08 17:27:42 +0100"
      },
      "new_version": {
        "version id": 4,
        "requirement id": 0,
        "content": "PEP: 771\nTitle: Default Extras for Python Software Packages\nAuthor: Thomas Robitaille <thomas.robitaille@gmail.com>, Jonathan Dekhtiar <jonathan@dekhtiar.com>\nSponsor: Pradyun Gedam <pradyunsg@gmail.com>\nDiscussions-To: https://discuss.python.org/t/94905/\nStatus: Draft\nType: Standards Track\nTopic: Packaging\nCreated: 13-Jan-2025\nPost-History:\n  `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n  `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n  `09-Jun-2025 <https://discuss.python.org/t/94905/>`__,\n\nAbstract\n========\n\n:pep:`508` specifies a mini-language for\ndeclaring package dependencies. One feature of this language is the ability to\nspecify *extras*, which are optional components of a distribution that, when\nused, install additional dependencies. This PEP proposes a mechanism to allow\none or more extras to be installed by default if none are provided explicitly.\n\nMotivation\n==========\n\nVarious use cases for default extras and possible solutions in this PEP were discussed\nextensively on `this DPO thread <https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__.\nThese fall into two broad cases that provide the\nmotivation for the present PEP.\n\nRecommended but not required dependencies\n-----------------------------------------\n\nPackage maintainers often use extras to declare optional dependencies that\nextend the functionality or performance of a package. In some cases, it can be\ndifficult to determine which dependencies should be required and which should be\ncategorized as extras. A balance must be struck between the needs of typical\nusers, who may prefer most features to be available by default, and users who\nwant minimal installations without large, optional dependencies. One solution\nwith existing Python packaging infrastructure is for package maintainers to\ndefine an extra called, for example, ``recommended``, which\nincludes all non-essential but suggested dependencies. Users are then instructed to\ninstall the package using ``package[recommended]``, while those who prefer more\ncontrol can use ``package``. However, in practice, many users are unaware\nof the ``[recommended]`` syntax, placing the burden on them to know this for a\ntypical installation. Having a way to have recommended dependencies be installed\nby default while providing a way for users to request a more minimal installation\nwould satisfy this use case, and this PEP describes a solution to this.\n\nExamples of packages that demonstrate this pattern by encouraging users to\ninclude extra dependencies by default include:\n\n* `astropy <https://www.astropy.org/>`_: ``astropy[recommended]``\n* `sunpy <https://www.sunpy.org/>`_: ``sunpy[all]``\n* `fastapi <https://fastapi.tiangolo.com/>`_: ``fastapi[standard]``\n\nPackages supporting multiple backends or frontends\n--------------------------------------------------\n\nAnother common use case for using extras is to define different backends or\nfrontends and dependencies that need to be installed for each backend or\nfrontend. A package might need at least one backend or frontend to be installed\nin order to be functional, but may be flexible on which backend or frontend this\nis. Concrete examples of such frontends or backends include:\n\n* The Qt frontend library, which can be provided by `PyQt5 <https://pypi.org/project/PyQt5/>`_, `PyQt6\n  <https://pypi.org/project/PyQt6/>`_, `PySide2\n  <https://pypi.org/project/PySide2/>`_, or `PySide6\n  <https://pypi.org/project/PySide6/>`_\n* Backend databases, such as `MySQL <https://www.mysql.com/>`_, `PostgreSQL\n  <https://www.postgresql.org/>`_, `SQLite <https://www.sqlite.org/>`_\n\nWith current packaging standards, maintainers have to either\nrequire one of the backends or frontends or require users\nto always specify extras, e.g., ``package[backend]``, and therefore risk users\nhaving an unusable installation if they only install ``package``. Having a\nway to specify one or more default backend or frontend and providing a way to\noverride these defaults would provide a much better experience for users, and\nthe approach described in this PEP will allow this.\n\nNote that this PEP does not aim to address the issue of disallowing conflicting\nor incompatible extras, for example if a package requires exactly one frontend\nor backend package. There is currently no mechanism in Python packaging\ninfrastructure to disallow conflicting or incompatible extras to be installed,\nand this PEP does not change that.\n\nExamples of packages that require at least one backend or frontend to work and\nrecommend a default extra to install a backend or frontend include:\n\n* `kivy <https://kivy.org/>`_: ``kivy[base]``\n\n* `napari <https://napari.org>`_: ``napari[all]``\n\n* `glueviz <https://www.glueviz.org>`_: ``glueviz[qt]``\n\nIn all three cases, installing the package without any extras results in a\nbroken installation, and this is a commonly reported support issue for some of these\npackages.\n\nRationale\n=========\n\nA number of possible solutions have been discussed extensively by\nthe community for several years, including in `this DPO thread\n<https://discuss.python.org/t/adding-a-default-extra-require-environment/4898>`__\nas well as in numerous issues and pull requests. The solution that is\npresented below:\n\n* is an opt-in solution which means that package maintainers can choose whether or not to use it\n* is flexible enough to accommodate both of the major use cases described in `Motivation`_\n* re-uses the syntax from :pep:`508`\n\nIt is the only solution, out of all those discussed, that meets all three criteria.\n\nSpecification\n=============\n\n``Default-Extra`` Metadata Field\n---------------------------------\n\nA new multiple-use metadata field, ``Default-Extra``, will be added to the `core package\nmetadata <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\nFor this field, each entry must be a string specifying an extra that will be\nautomatically included when the package is installed without any extras being specified explicitly.\n\nOnly entries already specified in a `Provides-Extra\n<https://packaging.python.org/en/latest/specifications/core-metadata/#provides-extra-multiple-use>`_\nentry can be used in a ``Default-Extra`` entry.\n\nExamples::\n\n    Default-Extra: recommended\n    Default-Extra: backend1\n    Default-Extra: backend2\n    Default-Extra: backend3\n\nSince this introduces a new field in the core package metadata, this will require\n`Metadata-Version <https://packaging.python.org/en/latest/specifications/core-metadata/#metadata-version>`_\nto be bumped to the next minor version (2.5 at the time of writing).\n\nNew key in ``[project]`` metadata table\n---------------------------------------\n\nA new key will be added to the ``[project]`` table in project metadata as\noriginally defined in :pep:`621` and now defined in the `PyPA specifications\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/>`_. This key will be named\n``default-optional-dependency-keys`` with the following description:\n\n* `TOML <https://toml.io/>`_ type: Array of strings\n* Corresponding core metadata field: ``Default-Extra``\n\nEach string in ``default-optional-dependency-keys`` must be the name of an extra\ndefined in `optional-dependencies\n<https://packaging.python.org/en/latest/specifications/pyproject-toml/#dependencies-optional-dependencies>`_,\nand each extra in this array will be converted to a matching ``Default-Extra``\nentry in the core package metadata. Examples of valid usage which would\nproduce the example ``Default-Extra`` entries presented in the previous section are:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\",\n    ]\n\nand:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\",\n        \"backend2\",\n        \"backend3\"\n    ]\n\nOverriding default extras\n-------------------------\n\nIf extras are explicitly given in a dependency specification, the default\nextras are ignored. Otherwise, the default extras are installed.\n\nFor example, if a package defines an ``extra1`` default extra as well as a\nnon-default ``extra2`` extra, then if a user were to install the package with:\n\n.. code-block:: console\n\n    $ pip install package\n\nthe default ``extra1`` dependency would be included. If the user instead\ninstalls the package with:\n\n.. code-block:: console\n\n    $ pip install package[extra2]\n\nthen the ``extra2`` extra would be installed but the default ``extra1`` extra\nwould be ignored.\n\nIf the same package is specified multiple times in an installation command or\ndependency tree, the default extras must be installed if any of the instances of\nthe package are specified without extras.  For instance, if one installs a\npackage ``spam`` where ``package`` appears several times in the dependency\ntree::\n\n    spam\n    \u251c\u2500\u2500 tomato\n    \u2502   \u251c\u2500\u2500 package[extra2]\n    \u2514\u2500\u2500 egg\n        \u2514\u2500\u2500 package\n\nthen the default extra should be installed because ``package`` appears at least\nonce with no extras specified.\n\nAn empty set of extras, such as ``package[]`` should be interpreted as meaning\nthat the package should be installed *without* any default extras (unless\n``package`` appears elsewhere in the dependency tree, in which case, the default\nextra *would* be installed as mentioned above). This\nwould provide a universal way of obtaining a minimal installation of a package.\n\nWe also note that some tools such as `pip`_ currently ignore unrecognized\nextras, and emit a warning to the user to indicate that the extra has not been\nrecognized, e.g:\n\n.. code-block:: console\n\n    $ pip install package[non-existent-extra]\n    WARNING: package 3.0.0 does not provide the extra 'non-existent-extra'\n    ...\n\nFor tools that behave like this (rather than raising an error), if an extra is\nrecognized as invalid in a dependency specification, it should be ignored, and\nif all specified extras are invalid, then this should be considered equivalent\nto ``package[]`` (rather than ``package``) and *not* install any default extras.\n\nFinally, we note (as also discussed in `Relying on tooling to deselect\nany default extras`_) that package installers are allowed to implement their\nown options to control the above behavior, for example implementing an option\nthat disables default extras for some or all packages regardless of where these\npackages appear in the dependency tree. If such tool-specific options are\nimplemented, tool developers should make these opt-in,\nand users should experience the above PEP 771 behavior as default.\n\nExamples\n--------\n\nIn this section we take a look at the use cases described in the `Motivation`_\nsection and how these can now be addressed by using the specification outlined\nabove.\n\nRecommended dependencies and minimal installations\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nFirst, we consider the case of packages that want recommended but not strictly\nrequired dependencies installed by default, while also providing a way to only\ninstall the required dependencies.\n\nIn order to do this, a package maintainer would define an extra called\n``recommended`` containing the recommended but not required dependencies, and\nwould choose to have this be included as a default extra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n\nIf this package was called ``package``, users installing ``package`` would\nthen get the equivalent of ``package[recommended]``. Users could alternatively\ninstall ``package[]`` which would install the package without the default extras.\n\nTo take a one of the concrete examples of package from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nWith this PEP, the ``recommended`` extra could be declared as being a default\nextra:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n\nmeaning that installing:\n\n.. code-block:: console\n\n    $ pip install astropy\n\nwould then install optional but recommended dependencies such as\n`scipy <https://www.scipy.org>`_. Advanced users who want a minimal install\ncould then use:\n\n.. code-block:: console\n\n    $ pip install astropy[]\n\nPackages requiring at least one backend or frontend\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAs described in `Motivation`_, some packages may support multiple backends\nand/or frontends, and in some cases it may be desirable to ensure that there\nis always at least one backend or frontend package installed, as the package\nwould be unusable otherwise. Concrete examples of this might include a GUI\napplication that needs a GUI library to be present to be usable but is able\nto support different ones, or a package that can rely on different computational\nbackends but needs at least one to be installed.\n\nIn this case, package maintainers could make the choice to define an extra\nfor each backend or frontend, and provide a default, e.g.:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"backend1\"\n    ]\n\n    [project.optional-dependencies]\n    backend1 = [\n        \"package1\",\n        \"package2\"\n    ]\n    backend2 = [\n        \"package3\"\n    ]\n\nIf packages can support e.g. multiple backends at the same time, and some of\nthe backends should always be installed, then the dependencies for these must be given\nas required dependencies rather than using the default extras mechanism.\n\nTo take one of the concrete examples mentioned in `Motivation`_, the `napari`_ package\ncan make use of one of `PyQt5`_, `PyQt6`_, `PySide2`_, or `PySide6`_, and users currently\nneed to explicitly specify ``napari[all]`` in order to have one of these be installed,\nor e.g., ``napari[pyqt5]`` to explicitly specify one of the frontend packages. Installing\n``napari`` with no extras results in a non-functional package. With this PEP, ``napari``\ncould define the following configuration:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"pyqt5\"\n    ]\n\n    [project.optional-dependencies]\n    pyqt5 = [\n        \"PyQt5\",\n        \"...\"\n    ]\n    pyside2 = [\n        \"PySide2\",\n        \"...\"\n    ]\n    pyqt6 = [\n        \"PyQt6\",\n        \"...\"\n    ]\n    pyside6 = [\n        \"PySide6\",\n        \"...\"\n    ]\n\nmeaning that:\n\n.. code-block:: console\n\n    $ pip install napari\n\nwould work out-of-the-box, but there would still be a mechanism for users to\nexplicitly specify a frontend, e.g.:\n\n.. code-block:: console\n\n    $ pip install napari[pyside6]\n\nSupporting extras that should not remove default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn additional case we consider here is where a package maintainer wants to\nsupport the ability for users to opt-in to non-default extras, without removing\ndefault extras. Essentially, they might want:\n\n* ``package[]`` to give an installation without any extras\n* ``package`` to install recommended dependencies (in a ``recommended`` extra)\n* ``package[alternative]`` to not install default extras, but to install an alternative set of optional dependencies (in an ``alternative`` extra)\n* ``package[additional]`` to install both recommended and additional dependencies (in an ``additional`` extra)\n\nThis could be achieved with e.g:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"package1\",\n        \"package2\"\n    ]\n    alternative = [\n        \"package3\"\n    ]\n    additional = [\n        \"package[recommended]\",\n        \"package4\"\n    ]\n\nThe ability for a package to reference itself in the extras is supported by\nexisting Python packaging tools.\n\nOnce again considering a concrete example, `astropy`_ could with this PEP define a\n``recommended`` extra (as described in `Recommended dependencies and minimal\ninstallations`_). However, it also defines other extras, including for example\n``jupyter``, which adds packages that\nenhance the user experience inside `Jupyter <https://jupyter.org/>`_-based\nenvironments. It is possible that users opting in to this extra would still want\nrecommended dependencies to be installed. In this case, the following\nconfiguration would solve this case:\n\n.. code-block:: toml\n\n    [project]\n    default-optional-dependency-keys = [\n        \"recommended\"\n    ]\n\n    [project.optional-dependencies]\n    recommended = [\n        \"scipy\",\n        \"...\"\n    ]\n    jupyter = [\n        \"astropy[recommended]\",\n        \"ipywidgets\",\n        \"...\"\n    ]\n\nUsers installing:\n\n.. code-block:: console\n\n    $ pip install astropy[jupyter]\n\nwould then get the same as:\n\n.. code-block:: console\n\n    $ pip install astropy[recommended, jupyter]\n\nPackages with multiple kinds of defaults\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages need multiple kinds of defaults. As an example,\nin `Packages requiring at least one backend or frontend`_, we considered the case of packages\nthat have *either* backends or frontends, but in some cases, packages may have to support\nbackends *and* frontends, and want to specify one or more default frontend and one or\nmore default backend.\n\nIdeally, one may want the following behavior:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1]  # installs backend1 and default frontend\n    $ pip install package[frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nHowever, this PEP chooses not to provide a mechanism for making it so that e.g., if\n``backend1`` is specified, the default backend would be disabled, but the\ndefault frontend would be enabled, since this adds complexity.\n\nMaintainers should instead for now document that if a backend or frontend is\nexplicitly specified, both backend and frontend need to be specified.\nDiscoverability for users who want to do this should not be an issue however since users\nneed to read the documentation in any case to find out what backends or frontends are\navailable, so they can be shown at the same time how to properly use the extras for\nbackends and frontends.\n\nOne option to increase user friendliness is that maintainers can create extras\ncalled for example ``defaultbackend`` and ``defaultfrontend`` which do install\nthe default backend and frontend. They can then recommend that users do:\n\n.. code-block:: console\n\n    $ pip install package  # installs default backend and frontend\n    $ pip install package[]  # installs no backends or frontends\n    $ pip install package[backend1, defaultfrontend]  # installs backend1 and default frontend\n    $ pip install package[defaultbackend, frontend2]  # installs frontend2 and default backend\n    $ pip install package[backend1, frontend2]  # installs backend1 and frontend2\n\nThis would allow (if desired) users to then get whatever the recommended backend\nis, even if that default changes in time.\n\nIf there is a desire to implement a better solution in future, we believe this\nPEP should not preclude this. For example, one could imagine in future adding\nthe ability for an extra to specify *which* default extras it disables, and if\nthis is not specified then explicitly specified extras would disable all default\nextras (consistent with the present PEP).\n\nBackward Compatibility\n======================\n\nPackages not using default extras\n---------------------------------\n\nOnce support for this PEP is added to tools in the packaging ecosystem, packages\nthat do not make use of default extras will continue to work as-is and there\nshould be no break in compatibility.\n\nPackages using default extras\n-----------------------------\n\nOnce packages start defining default extras, those defaults will only be honored\nwith recent versions of packaging tools which implement this PEP, but those\npackages will remain installable with older packaging tools -- with the main\ndifference being that the default extras will not be installed automatically\nwhen older packaging tools are used.\n\nAs described in `How to teach this`_,\npackage authors need to carefully evaluate when and how they adopt\nthe default extra feature depending on their user base, as some actions (such as\nmoving a required dependency to a default extra) will likely result in breakage\nfor users if a significant fraction of them are still using older package\ninstallers that do not support default extras. In this sense, package authors\nshould be aware that this feature, if used in certain ways, can cause\nbackward-compatibility issues for users, and they are thus responsible for\nensuring that they minimize the impact to users.\n\nPackaging-related tools\n-----------------------\n\nThe most significant backward-compatibility aspect is related to assumptions\npackaging tools make about extras -- specifically, this PEP changes the\nassumption that extras are no longer exclusively additive in terms of adding\ndependencies to the dependency tree, and specifying some extras can result in\nfewer dependencies being installed.\n\nA specific example of change in behavior can be seen with `pip`_: consider a\npackage ``package`` which has a required dependency of ``numpy``, and a default\nextra called ``recommended`` which includes ``scipy``. If a user installs\n``package[]``, only ``package`` and ``numpy`` will be installed. If a user then\ndoes:\n\n.. code-block:: console\n\n    $ pip freeze > requirements.txt\n\nthen ``requirements.txt`` will contain e.g.::\n\n    package==1.0.2\n    numpy==2.1.0\n\nHowever, if the user then installs the requirements from this file using:\n\n.. code-block:: console\n\n    $ pip install -r requirements.txt\n\nthen pip will install ``package`` (which will include the default extra) as well\nas ``numpy``, so the final environment will contain ``scipy``. A solution in this\nspecific case is for the user to pass ``--no-deps`` to ``pip install`` to avoid\nresolving the dependency tree, but the point here is to illustrate that there\nmay be changes in behavior in packaging tools due to the change in the\nassumption about what impact an extra can have.\n\nIt is worth noting that the recently-accepted :pep:`751` defines a new file\nformat which is intended to replace alternatives such as the ``pip freeze``\noutput and other tools in future. The new file format is designed so that the\npackages in the file are installed *without* resolving dependencies, which means\nthat it will be fully compatible with default extras as specified in this PEP,\nand will avoid the issue with ``pip freeze``/``pip install -r`` mentioned above.\n\nSecurity Implications\n=====================\n\nThere are no known security implications for this PEP.\n\nHow to teach this\n=================\n\nThis section outlines information that should be made available to people in\ndifferent groups in the community in relation to the implementation of this PEP.\nSome aspects described below will be relevant even before the PEP is fully\nimplemented in packaging tools as there are some preparations that can be done\nin advance of this implementation to facilitate any potential transition later\non. The groups covered below are:\n\n- `Package end users`_\n- `Package authors`_\n- `Packaging repository maintainers`_\n\nPackage end users\n-----------------\n\nPackage users should be provided with clear installation instructions that show\nwhat extras are available for packages and how they behave, for example\nexplaining that by default some recommended dependencies or a given frontend or\nbackend will be installed, and how to opt out of this or override defaults,\ndepending what is available.\n\nPackage authors\n---------------\n\nWhile the mechanism used to define extras and the associated rule about when to\nuse it are clear, package authors need to carefully consider several points\nbefore adopting this capability in their packages, to avoid inadvertently breaking\nbackward-compatibility.\n\nSupporting older versions of package installers\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackage installers such as `pip`_ or `uv <https://docs.astral.sh/uv/>`_ will not\nnecessarily implement support for default extras at the same time, and once they\ndo it is likely that package authors will want to keep supporting users who do\nnot have the most recent version of a package installer. In this case, the\nfollowing recommendations would apply:\n\n* Moving a package from being a required dependency to a default extra would be\n  a breaking change, because older versions of package installers would not\n  recognise the concept of default extras, and would then install the package\n  with fewer dependencies, which could affect users that would have been relying\n  on these. Therefore, changing dependencies from required to a default extra in\n  an established package should only be done in future once the developers only\n  want to support users with installers that implement this PEP.\n\n* Making an existing extra become a default should be safer, such as making\n  ``recommended`` in `astropy`_ be a default extra, but in order to support users\n  with older versions of package installers, the documentation should still mention\n  the extra explicitly as long as possible (until it is clear that most/all users\n  are using package installers that implement this PEP). There is no downside to\n  keeping the extra be explicitly mentioned, but this will ensure that users with\n  modern tooling who do not read documentation (which may be a non-negligible\n  fraction of the user community) will start getting the recommended\n  dependencies by default.\n\n* Since prior to this PEP, ``package[]`` was equivalent to ``package``,\n  authors will be able to document ``package[]`` as a backward-compatible\n  universal way of getting a minimal installation. For packages that define\n  default extras, installing ``package[]`` will always give a minimal\n  installation even with older versions of packaging tools such as `pip`_, and\n  releases of this package that pre-date the introduction of default extras for\n  a specific package will also be installable with ``package[]`` (although in\n  these cases this will be equivalent to ``package``). For packages that do not\n  define default extras, ``package[]`` will continue to be equivalent to\n  ``package``.\n\nAvoiding the addition of many default dependencies\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOne temptation for authors might be to include many dependencies by default since\nthey can provide a way to opt out from these. We recommend however that authors\ncarefully consider what is included by default to avoid unnecessarily bloating\ninstallations and complicating dependency trees. Using default extras does not\nmean that all extras need to be defaults, and there is still scope for users to\nexplicitly opt in to non-default extras.\n\nDefault extras should generally be treated with the same \"weight\" as required\ndependencies. When a package is widely used, introducing a default extra will\nresult in that extra's dependencies being transitively included -- unless all\ndownstream packages are updated to explicitly opt out using minimal installation\nspecifications.\n\nAs an example, the `pytest <https://docs.pytest.org/>`_ package currently has nearly 1,500 plugins that depend on it. If pytest were to add a default extra and those plugins were not updated accordingly, installing a plugin would include the default extras' dependencies. This doesn\u2019t preclude the use of default extras, but addition of default extras requires careful evaluation of its downstream effects.\n\nInheriting from default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf package authors choose to make an extra be installed by default, it is important\nthat they are aware that if users explicitly specify another extra, the default may\nnot be installed, unless they use the approach described in `Supporting extras\nthat should not remove default extras`_.\n\nThere are cases, such as the interchangeable backends,\nwhere ignoring the default if an extra is explicitly specified is the right\nthing to do. However, for other cases, such as using default extras to include\nrecommended dependencies while still providing a way to do minimal installs, it\nmay be that many of the other extras *should* explicitly 'inherit' the default\nextra(s), so package authors should carefully consider in which cases they want\nthe default extras to be installed.\n\nIncompatible extras\n^^^^^^^^^^^^^^^^^^^\n\nIn some cases, it may be that packages have extras that are mutually\nincompatible. In this case, we recommend against using the default extra\nfeature for any extra that contains a dependency that could be incompatible with\nanother.\n\nConsider a package that has extras ``package[A]`` and ``package[B]``. Users\ncould already currently try and install ``package[A]`` and ``package[B]`` or\n``package[A,B]`` which would result in a broken installation, however it would\nat least be explicit that both extras were being installed. Making ``A`` into a\ndefault extra however could lead to unintuitive issues. A user could do:\n\n.. code-block:: console\n\n    $ pip install package  # this installs package[A]\n    $ pip install package[B]\n\nand end up with a broken installation, even though A and B were never explicitly\nboth installed. For this reason, we recommend against using default extras\nfor dependencies where this is likely to be an issue.\n\nCircular dependencies\n^^^^^^^^^^^^^^^^^^^^^\n\nAuthors need to take special care when circular dependencies are present. For instance,\nconsider the following dependency tree::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1\n\nIf ``package1`` has a default extra named ``recommended`` then:\n\n.. code-block:: console\n\n    $ pip install package1[]\n\nwill still result in the ``recommended`` extra being installed if ``package2``\ncontinues to depend on ``package1`` (with no extras specified). This could be\nsolved by changing the dependency tree to instead be::\n\n    package1\n    \u2514\u2500\u2500 package2\n        \u2514\u2500\u2500 package1[]\n\nassuming that indeed ``package2`` does not depend on any features provided by\nthe extra dependencies of ``package1``. Authors therefore need to carefully\nconsider a migration plan, coordinating with the authors of ``package2``.\n\nDocumenting packages with default extras\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nRegardless of how default extras are used, package authors should aim to ensure\nthat their package's documentation makes it clear how extras are to be\nused. 'Best practices' documentation should mention:\n\n* that installing ``package`` will be equivalent to ``package[<default extras>]``\n* that installing ``package[]`` will include only minimal/required dependencies,\n  but that this will not guarantee that optional dependencies do not get installed\n  if ``package`` appears anywhere else in the dependency tree\n* what other optional extras are available, and whether or not they disable the\n  default extras (since this can be controlled as described in `Supporting\n  extras that should not remove default extras`_)\n* any instructions specific to packages that might have e.g. default backends\n  *and* frontends (as described in `Packages with multiple kinds of defaults`_)\n\nPackaging repository maintainers\n--------------------------------\n\nThe impact on individuals who repackage Python libraries for different\ndistributions, such as `conda <https://docs.conda.io>`_, `Homebrew\n<https://brew.sh/>`_, linux package installers (such as ``apt`` and ``yum``) and\nso on, needs to be considered. Not all package distributions have mechanisms\nthat would line up with the approach described. In fact, some distributions such\nas conda, do not even have the concept of extras.\n\nThere are two cases to consider here:\n\n* In cases where the repackaging is done by hand, such as for a number of conda-forge\n  recipes, and especially where there is no equivalent to extras, the\n  introduction of default extras should not have a large impact since manual\n  decisions already have to be made as to which dependencies to include (for\n  example, the conda-forge recipe for the `astropy`_ package mentioned in the\n  `Motivation`_ includes all the ``recommended`` dependencies by default since\n  there is no way for users to explicitly request them otherwise).\n\n* In cases where the repackaging is done in an automated, way, distribution maintainers\n  will need to carefully consider how to treat default extras, and this may\n  imply a non-negligible amount of work and discussion.\n\nIt is impossible for a PEP such as this to exhaustively consider each of the\ndifferent package distributions. However, ultimately, default extras should be\nunderstood as how package authors would like their package to be installed for\nthe majority of users, and this should inform decisions about how default extras\nshould be handled, whether manually or automatically.\n\nReference Implementation\n========================\n\nThe following repository contains a fully functional demo package\nthat makes use of default extras:\n\nhttps://github.com/wheel-next/pep_771\n\nThis makes use of modified branches of several packages, and the following\nlinks are to these branches:\n\n* `Setuptools <https://github.com/wheel-next/setuptools/tree/pep_771>`_\n* `pip <https://github.com/wheel-next/pip/tree/pep_771>`_\n* `importlib_metadata <https://github.com/wheel-next/importlib_metadata/tree/pep_771>`_\n\nIn addition, `this branch <https://github.com/astrofrog/flit/tree/default-extras-pep>`_\ncontains a modified version of the `Flit\n<https://flit.pypa.io/en/stable/>`_ package.\n\nThe implementations above are proofs-of-concept at this time and the existing changes have\nnot yet been reviewed by the relevant maintainers. Nevertheless, they are\nfunctional enough to allow for interested maintainers to try these out.\n\nRejected Ideas\n==============\n\nUsing a meta-package for recommended installations\n--------------------------------------------------\n\nUsing existing packaging tools and infrastructure, package maintainers who want\nto provide a minimal installation for some users and a default non-minimal\ninstallation for regular users (e.g. with recommended dependencies or a default\nbackend) can technically already achieve this if they are willing to distribute\ntwo packages instead of one -- for example ``package-core`` which would be the main package\nwith minimal dependencies, and ``package`` which would be a metapackage that\nwould depend on ``package-core`` with optional dependencies enabled.\n\nTaking once again a concrete example from the `Motivation`_\nsection, the `astropy`_ package defines a ``recommended`` extra that users are\ncurrently instructed to install in the default installation instructions.\nIn principle, one could rename the existing ``astropy`` package to e.g. ``astropy-core``\nand then create a new ``astropy`` package which would be a metapackage that would\ncontain the following dependencies section:\n\n.. code-block:: toml\n\n    dependencies = [\n        \"astropy-core[recommended]\"\n    ]\n\nSince users may want to pin or place version constraints on the ``astropy``\nmeta-package (e.g. ``astropy>5.0``), the metapackage would need to follow\nthe same versions as the core package, and would need to use strict pinning\nin the dependency section, e.g.:\n\n.. code-block:: toml\n\n    version = \"7.1.0\"\n    dependencies = [\n        \"astropy-core[recommended]==7.1.0\"\n    ]\n\nThis idea may seem appealing because it is technically already feasible. However, in\npractice, many projects have opted not to do this, for a number of reasons, which\nwe now take a look at. Some of these may not be applicable to future new projects,\nbut some of them apply to all projects, old and new.\n\nMismatch between package and module name\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIn terms of naming, there are two main options for a package that wants to use the metapackage\napproach:\n\n* The first option is for the existing package to be kept as-is, which means\n  that ``package`` would provide the minimal installation, and to then create a\n  new metapackage with a different name, such as ``package-all``. However, this\n  suffers from one of the problems that motivated this PEP in the first place -\n  users are often not aware that they can do e.g. ``package[recommended]``, so\n  in the same way, they might not realise that ``package-all`` exists. This once\n  again places the burden on the average user to discover this, rather then\n  shifting some of the burden to more advanced users.\n\n* The second option is for the existing package to be renamed to e.g. ``package-core``, and\n  for the new meta-package to be called ``package``. This is a better option\n  than the first one, but is not ideal, as it then introduces a non-intuitive\n  mismatch between the package name and module name, in that ``package-core`` provides\n  the ``package`` module, and ``package`` does not provide any module. An example of why\n  this would lead to confusion is that an average user might think that uninstalling\n  the ``package`` module would be done with e.g.:\n\n  .. code-block:: shell\n\n      $ pip uninstall package\n\n  but this would not be the case (the ``package`` module would still work), and\n  it may not be obvious to this user that the ``package-core`` package even\n  exists.\n\nMultiple repositories or monorepos\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThis approach requires either maintaining two repositories instead of one, or\nswitching to using a monorepo which would contain both packages. Neither option\nis ideal:\n\n* Splitting into two repositories places a long-term additional burden on\n  maintainers, who have to make sure that these stay in sync (in terms of\n  version but also other aspects such as extras, as will be discussed in\n  `Synchronizing metadata`_). In addition, the naming issue mentioned in\n  `Mismatch between package and module name`_ has additional complications here\n  \u2013\u00a0either the names of the repositories match the packages, in which case any\n  user who has a checkout of the previous ``package`` repository will need to\n  update their remote URLs or any git clone URLs to point to the\n  ``package-core`` repository. The alternative is to preserve the ``package``\n  repository to contain the ``package-core`` package, and have a different name\n  for the meta-package, but this could lead to confusion.\n\n* Switching to a monorepo may be a significant change for some projects,\n  and it is not uncommon for tools to assume by default that a single repository\n  corresponds to a single package - while these can often be configured to then\n  work with a monorepo, it is an additional burden on the maintainers. In\n  addition, if the main package is moved to a sub-directory in the monorepo, any\n  user that is e.g. pip installing the package from the repository URL will need\n  to adjust this to install from a sub-directory (adding ``subdirectory=`` to\n  the repo URL), and any existing workflows that clone the repository and assume\n  the previous layout would break.\n\nDepending on the minimal package\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nPackages that need to depend on package versions that are older than the first\nversion where the split was done will not easily be able to depend on the\nminimal package. Whereas with the main proposal in this PEP, downstream users\nwill be able to depend on e.g. ``package[]>version`` where ``version`` pre-dates\nthe introduction of default extras, with the splitting approach it will not be\npossible for downstream users to depend on e.g. ``package-core>version``, since\n``package-core`` did not previously exist.\n\nA possible solution to this is for developers to release no-op metadata packages\nfor all old versions of a package, but this is a significant additional burden\non the maintainers.\n\nUninstallation\n^^^^^^^^^^^^^^\n\nAs alluded to when referring to naming issues in `Mismatch between package and\nmodule name`_, uninstalling packages will no longer work the way users expect. A\nuser doing:\n\n.. code-block:: shell\n\n    $ pip uninstall package\n\nwill still be left with ``package-core``, but may not realise it. This is\nnot just confusing, but is in effect a breaking change that may impact a number\nof existing workflows.\n\nPackage distributions\n^^^^^^^^^^^^^^^^^^^^^\n\nHaving two packages instead of one would increase the long-term maintenance cost\nof package distributions simply by virtue of the fact that two packages would\nhave to be released instead of one, and in some cases this would introduce extra\nmanual work at each release.\n\nSynchronizing metadata\n^^^^^^^^^^^^^^^^^^^^^^\n\nThe main metadata that would be important to keep synchronized between the main\npackage and the metapackage is the version. Anytime a new release of the core\npackage is done, the metapackage would need to have its version updated as well\nas the version pinning for the core package in the dependencies.\n\nIn addition, all extras defined in the core package would need to be redefined\nand kept in sync in the metapackage. For example, if ``package`` defines a\n``additional`` extra, users should still be able to install\n``package[additional]``, but users installing the ``package-core`` package should\nalso have the option of doing ``package-core[additional]``.\n\nOther metadata that would need to be kept in sync includes for example author\ninformation and project URLs.\n\nSummary\n^^^^^^^\n\nOverall, this solution would imply a significantly higher maintenance burden,\nnot just in terms of initial set-up and transition (which could already be\nprohibitive for large established projects), but also in terms of long-term\nmaintenance. This also has the potential for breaking user workflows (in\nparticular around the issue of repositories, and e.g. uninstallation). For all\nthese reasons, we do not consider it a compelling alternative to the present PEP.\n\nSyntax for deselecting extras\n-----------------------------\n\nOne of the main competing approaches was as follows: instead of having defaults\nbe unselected if any extras were explicitly provided, default extras would need\nto be explicitly unselected.\n\nIn this picture, a new syntax for unselecting extras would be introduced as an\nextension of the mini-language defined in :pep:`508`. If a package defined\ndefault extras, users could opt out of these defaults by using a minus sign\n(``-``) before the extra name. The proposed syntax update would have been as follows::\n\n    extras_list   = (-)?identifier (wsp* ',' wsp* (-)?identifier)*\n\nValid examples of this new syntax would have included, e.g.:\n\n* ``package[-recommended]``\n* ``package[-backend1, backend2]``\n* ``package[pdf, -svg]``\n\nHowever, there are two main issues with this approach:\n\n* One would need to define a number of rules for how to interpret corner cases\n  such as if an extra and its negated version were both present in the same\n  dependency specification (e.g. ``package[pdf, -pdf]``) or if a dependency\n  tree included both ``package[pdf]`` and ``package[-pdf]``, and the rules would\n  not be intuitive to users.\n\n* More critically, this would introduce new syntax into dependency specification,\n  which means that if any package defined a dependency using the new syntax, it\n  and any other package depending on it would no longer be installable by existing\n  packaging tools, so this would be a major backward compatibility break.\n\nFor these reasons, this alternative was not included in the final proposal.\n\nAdding a special entry in ``extras_require``\n--------------------------------------------\n\nA potential solution that has been explored as an alternative to introducing the\nnew ``Default-Extra`` metadata field would be to make use of an extra with a\n'special' name.\n\nOne example would be to use an empty string::\n\n    Provides-Extra:\n    Requires-Dist: numpy ; extra == ''\n\nThe idea would be that dependencies installed as part of the 'empty' extras\nwould only get installed if another extra was not specified. An implementation\nof this was proposed in https://github.com/pypa/setuptools/pull/1503, but it\nwas found that there would be no way to make this work without breaking\ncompatibility with existing usage. For example, packages using Setuptools via\na ``setup.py`` file can do::\n\n    setup(\n        ...\n        extras_require={'': ['package_a']},\n    )\n\nwhich is valid and equivalent to having ``package_a`` being defined in\n``install_requires``, so changing the meaning of the empty string would\nbreak compatibility.\n\nIn addition, no other string (such as ``'default'``) can be used as a special\nstring since all strings that would be a backward-compatible valid extras name\nmay already be used in existing packages.\n\nThere have been suggestions of using the special ``None`` Python variable, but\nagain this is not possible, because even though one can use ``None`` in a ``setup.py`` file,\nthis is not possible in declarative files such as ``setup.cfg`` or\n``pyproject.toml``, and furthermore ultimately extras names have to be converted\nto strings in the package metadata. Having::\n\n    Provides-Extra: None\n\nwould be indistinguishable from the string 'None' which may already be used as\nan extra name in a Python package. If we were to modify the core metadata\nsyntax to allow non-string 'special' extras names, then we would be back to\nmodifying the core metadata specification, which is no better than\nintroducing ``Default-Extra``.\n\nRelying on tooling to deselect any default extras\n-------------------------------------------------\n\nAnother option to unselect extras would be to implement this at the\nlevel of packaging tools. For instance, pip could include an option such as:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras\n\nThis option could apply to all or specific packages, similar to\nthe ``--no-binary`` option, e.g.,:\n\n.. code-block:: console\n\n    $ pip install package --no-default-extras :all:\n\nThe advantage of this approach is that tools supporting default extras could\nalso support unselecting them. This approach would be similar to the ``--no-install-recommends``\noption for the ``apt`` tool.\n\nHowever, this solution is not ideal on its own because it would not allow packages to\nspecify themselves that they do not need some of the default extras of a\ndependency. It would also carry risks for users who might disable all default\nextras in a big dependency tree, potentially breaking packages in the tree that\nrely on default extras at any point.\n\nNevertheless, this PEP does not disallow this approach and it is up to the\nmaintainers of different packaging tools to decide if they want to support this\nkind of option. It is a flag that could at the very least be useful for package\nmaintainers who want to identify places in dependency trees where default extras\nare being relied on. However, if it is supported, it should be made clear that\nusing this flag does not guarantee a functional environment.\n\nCopyright\n=========\n\nThis document is placed in the public domain or under the\nCC0-1.0-Universal license, whichever is more permissive.",
        "commit_hash": "816c0571f4050faf47c6a88cdcd9da7a4e94bc6f",
        "date": "2025-06-09 12:29:19 +0100"
      },
      "diff": "Post-History:\n   `15-Jan-2025 <https://discuss.python.org/t/77892/>`__,\n   `06-Feb-2025 <https://discuss.python.org/t/79706/>`__,\n+  `09-Jun-2025 <https://discuss.python.org/t/94905/>`__,\n \n Abstract\n ========",
      "old_content_snippet": "",
      "new_content_snippet": ""
    }
  ]
}